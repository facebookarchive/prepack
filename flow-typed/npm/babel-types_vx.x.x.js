// flow-typed signature: e65b014cd6fc2636d93a98c55ee45a1a
// flow-typed version: <<STUB>>/babel-types_v^6.9.0/flow_v0.38.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'babel-types'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */
// NOTE: This file is autogenerated. Do not modify.
// See [babel GIT root]/scripts/generate-interfaces.js for script used.


declare module "@babel/types" {
  declare type BabelObjectMethodKind = "get" | "set" | "method";
  declare type BabelLogicalOperator = "||" | "&&";
  declare type BabelAssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";
  declare type BabelBinaryOperator = "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=";
  declare type BabelUnaryOperator = "void" | "delete" | "!" | "+" | "-" | "++" | "--" | "~" | "typeof";
  declare type BabelUpdateOperator = "++" | "--";
  declare type BabelVariableKind = "var" | "let" | "const";

  declare class BabelNodeComment {
    +type: "BlockComment" | "LineComment";
    value: string;
    start: number;
    end: number;
    loc: BabelNodeSourceLocation;
  }

  declare class BabelNodeBlockComment extends BabelNodeComment {
    type: "BlockComment";
  }

  declare class BabelNodeLineComment extends BabelNodeComment {
    type: "LineComment";
  }

  declare class BabelNodePosition {
    line: number;
    column: number;
  }

  declare class BabelNodeSourceLocation {
    source: string | null;
    start: BabelNodePosition;
    end: BabelNodePosition;
  }

  declare class BabelNode {
    +type: "ArrayExpression" |
      "AssignmentExpression" |
      "BinaryExpression" |
      "Directive" |
      "DirectiveLiteral" |
      "BlockStatement" |
      "BreakStatement" |
      "CallExpression" |
      "CatchClause" |
      "ConditionalExpression" |
      "ContinueStatement" |
      "DebuggerStatement" |
      "DoWhileStatement" |
      "EmptyStatement" |
      "ExpressionStatement" |
      "File" |
      "ForInStatement" |
      "ForStatement" |
      "FunctionDeclaration" |
      "FunctionExpression" |
      "Identifier" |
      "IfStatement" |
      "LabeledStatement" |
      "StringLiteral" |
      "NumericLiteral" |
      "NullLiteral" |
      "BooleanLiteral" |
      "RegExpLiteral" |
      "LogicalExpression" |
      "MemberExpression" |
      "NewExpression" |
      "Program" |
      "ObjectExpression" |
      "ObjectMethod" |
      "ObjectProperty" |
      "RestElement" |
      "ReturnStatement" |
      "SequenceExpression" |
      "SwitchCase" |
      "SwitchStatement" |
      "ThisExpression" |
      "ThrowStatement" |
      "TryStatement" |
      "UnaryExpression" |
      "UpdateExpression" |
      "VariableDeclaration" |
      "VariableDeclarator" |
      "WhileStatement" |
      "WithStatement" |
      "AssignmentPattern" |
      "ArrayPattern" |
      "ArrowFunctionExpression" |
      "ClassBody" |
      "ClassDeclaration" |
      "ClassExpression" |
      "ExportAllDeclaration" |
      "ExportDefaultDeclaration" |
      "ExportNamedDeclaration" |
      "ExportSpecifier" |
      "ForOfStatement" |
      "ImportDeclaration" |
      "ImportDefaultSpecifier" |
      "ImportNamespaceSpecifier" |
      "ImportSpecifier" |
      "MetaProperty" |
      "ClassMethod" |
      "ObjectPattern" |
      "SpreadElement" |
      "Super" |
      "TaggedTemplateExpression" |
      "TemplateElement" |
      "TemplateLiteral" |
      "YieldExpression" |
      "AnyTypeAnnotation" |
      "ArrayTypeAnnotation" |
      "BooleanTypeAnnotation" |
      "BooleanLiteralTypeAnnotation" |
      "NullLiteralTypeAnnotation" |
      "ClassImplements" |
      "ClassProperty" |
      "DeclareClass" |
      "DeclareFunction" |
      "DeclareInterface" |
      "DeclareModule" |
      "DeclareModuleExports" |
      "DeclareTypeAlias" |
      "DeclareVariable" |
      "ExistentialTypeParam" |
      "FunctionTypeAnnotation" |
      "FunctionTypeParam" |
      "GenericTypeAnnotation" |
      "InterfaceExtends" |
      "InterfaceDeclaration" |
      "IntersectionTypeAnnotation" |
      "MixedTypeAnnotation" |
      "EmptyTypeAnnotation" |
      "NullableTypeAnnotation" |
      "NumericLiteralTypeAnnotation" |
      "NumberTypeAnnotation" |
      "StringLiteralTypeAnnotation" |
      "StringTypeAnnotation" |
      "ThisTypeAnnotation" |
      "TupleTypeAnnotation" |
      "TypeofTypeAnnotation" |
      "TypeAlias" |
      "TypeAnnotation" |
      "TypeCastExpression" |
      "TypeParameter" |
      "TypeParameterDeclaration" |
      "TypeParameterInstantiation" |
      "ObjectTypeAnnotation" |
      "ObjectTypeCallProperty" |
      "ObjectTypeIndexer" |
      "ObjectTypeProperty" |
      "QualifiedTypeIdentifier" |
      "UnionTypeAnnotation" |
      "VoidTypeAnnotation" |
      "JSXAttribute" |
      "JSXClosingElement" |
      "JSXElement" |
      "JSXEmptyExpression" |
      "JSXExpressionContainer" |
      "JSXIdentifier" |
      "JSXMemberExpression" |
      "JSXNamespacedName" |
      "JSXOpeningElement" |
      "JSXSpreadAttribute" |
      "JSXText" |
      "Noop" |
      "ParenthesizedExpression" |
      "AwaitExpression" |
      "ForAwaitStatement" |
      "BindExpression" |
      "Decorator" |
      "DoExpression" |
      "ExportDefaultSpecifier" |
      "ExportNamespaceSpecifier" |
      "RestProperty" ;
    leadingComments: ?Array<BabelNodeComment>;
    innerComments: ?Array<BabelNodeComment>;
    trailingComments: ?Array<BabelNodeComment>;
    start: ?number;
    end: ?number;
    loc: ?BabelNodeSourceLocation;
  }

  declare class BabelNodeArrayExpression extends BabelNode {
    type: "ArrayExpression";
    elements: Array<void | BabelNodeExpression | BabelNodeSpreadElement>;
  }

  declare class BabelNodeAssignmentExpression extends BabelNode {
    type: "AssignmentExpression";
    operator: BabelAssignmentOperator;
    left: BabelNodeLVal;
    right: BabelNodeExpression;
  }

  declare class BabelNodeBinaryExpression extends BabelNode {
    type: "BinaryExpression";
    operator: BabelBinaryOperator;
    left: BabelNodeExpression;
    right: BabelNodeExpression;
  }

  declare class BabelNodeDirective extends BabelNode {
    type: "Directive";
    value: BabelNodeDirectiveLiteral;
  }

  declare class BabelNodeDirectiveLiteral extends BabelNode {
    type: "DirectiveLiteral";
    value: string;
  }

  declare class BabelNodeBlockStatement extends BabelNode {
    type: "BlockStatement";
    directives?: Array<BabelNodeDirective>;
    body: Array<BabelNodeStatement>;
  }

  declare class BabelNodeBreakStatement extends BabelNode {
    type: "BreakStatement";
    label?: ?BabelNodeIdentifier;
  }

  declare class BabelNodeCallExpression extends BabelNode {
    type: "CallExpression";
    callee: BabelNodeExpression;
    arguments: Array<BabelNodeExpression | BabelNodeSpreadElement>;
  }

  declare class BabelNodeCatchClause extends BabelNode {
    type: "CatchClause";
    param: BabelNodePattern;
    body: BabelNodeBlockStatement;
  }

  declare class BabelNodeConditionalExpression extends BabelNode {
    type: "ConditionalExpression";
    test: BabelNodeExpression;
    consequent: BabelNodeExpression;
    alternate: BabelNodeExpression;
  }

  declare class BabelNodeContinueStatement extends BabelNode {
    type: "ContinueStatement";
    label?: ?BabelNodeIdentifier;
  }

  declare class BabelNodeDebuggerStatement extends BabelNode {
    type: "DebuggerStatement";
  }

  declare class BabelNodeDoWhileStatement extends BabelNode {
    type: "DoWhileStatement";
    test: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeEmptyStatement extends BabelNode {
    type: "EmptyStatement";
  }

  declare class BabelNodeExpressionStatement extends BabelNode {
    type: "ExpressionStatement";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeFile extends BabelNode {
    type: "File";
    program: BabelNodeProgram;
    comments: any;
    tokens: any;
  }

  declare class BabelNodeForInStatement extends BabelNode {
    type: "ForInStatement";
    left: BabelNodeVariableDeclaration | BabelNodeLVal;
    right: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeForStatement extends BabelNode {
    type: "ForStatement";
    init?: ?BabelNodeVariableDeclaration | BabelNodeExpression;
    test?: ?BabelNodeExpression;
    update?: ?BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeFunctionDeclaration extends BabelNode {
    type: "FunctionDeclaration";
    id: BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator: boolean;
    async: boolean;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeFunctionExpression extends BabelNode {
    type: "FunctionExpression";
    id?: ?BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator?: boolean;
    async?: boolean;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeIdentifier extends BabelNode {
    type: "Identifier";
    name: string;
    decorators?: any;
    typeAnnotation?: any;
  }

  declare class BabelNodeIfStatement extends BabelNode {
    type: "IfStatement";
    test: BabelNodeExpression;
    consequent: BabelNodeStatement;
    alternate?: ?BabelNodeStatement;
  }

  declare class BabelNodeLabeledStatement extends BabelNode {
    type: "LabeledStatement";
    label: BabelNodeIdentifier;
    body: BabelNodeStatement;
  }

  declare class BabelNodeStringLiteral extends BabelNode {
    type: "StringLiteral";
    value: string;
  }

  declare class BabelNodeNumericLiteral extends BabelNode {
    type: "NumericLiteral";
    value: number;
  }

  declare class BabelNodeNullLiteral extends BabelNode {
    type: "NullLiteral";
  }

  declare class BabelNodeBooleanLiteral extends BabelNode {
    type: "BooleanLiteral";
    value: boolean;
  }

  declare class BabelNodeRegExpLiteral extends BabelNode {
    type: "RegExpLiteral";
    pattern: string;
    flags?: string;
  }

  declare class BabelNodeLogicalExpression extends BabelNode {
    type: "LogicalExpression";
    operator: BabelLogicalOperator;
    left: BabelNodeExpression;
    right: BabelNodeExpression;
  }

  declare class BabelNodeMemberExpression extends BabelNode {
    type: "MemberExpression";
    object: BabelNodeExpression;
    property: any;
    computed?: boolean;
  }

  declare class BabelNodeNewExpression extends BabelNode {
    type: "NewExpression";
    callee: BabelNodeExpression;
    arguments: Array<BabelNode>;
  }

  declare class BabelNodeProgram extends BabelNode {
    type: "Program";
    sourceType: "script" | "module";
    directives?: Array<BabelNodeDirective>;
    body: Array<BabelNodeStatement | BabelNodeModuleDeclaration>;
  }

  declare class BabelNodeObjectExpression extends BabelNode {
    type: "ObjectExpression";
    properties: Array<BabelNodeObjectProperty>;
  }

  declare class BabelNodeObjectMethod extends BabelNode {
    type: "ObjectMethod";
    kind: BabelObjectMethodKind;
    computed: boolean;
    key: BabelNodeExpression;
    decorators: Array<BabelNodeDecorator>;
    value: BabelNodeExpression;
    id?: ?BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator?: boolean;
    async: boolean;
  }

  declare class BabelNodeObjectProperty extends BabelNode {
    type: "ObjectProperty";
    computed: boolean;
    key: BabelNodeExpression;
    decorators: Array<BabelNodeDecorator>;
    value: BabelNodeExpression;
  }

  declare class BabelNodeRestElement extends BabelNode {
    type: "RestElement";
    argument: BabelNodePattern;
    decorators?: any;
    typeAnnotation: any;
  }

  declare class BabelNodeReturnStatement extends BabelNode {
    type: "ReturnStatement";
    argument?: ?BabelNodeExpression;
  }

  declare class BabelNodeSequenceExpression extends BabelNode {
    type: "SequenceExpression";
    expressions: Array<BabelNodeExpression>;
  }

  declare class BabelNodeSwitchCase extends BabelNode {
    type: "SwitchCase";
    test?: ?BabelNodeExpression;
    consequent: Array<BabelNodeStatement>;
  }

  declare class BabelNodeSwitchStatement extends BabelNode {
    type: "SwitchStatement";
    discriminant: BabelNodeExpression;
    cases: Array<BabelNodeSwitchCase>;
  }

  declare class BabelNodeThisExpression extends BabelNode {
    type: "ThisExpression";
  }

  declare class BabelNodeThrowStatement extends BabelNode {
    type: "ThrowStatement";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeTryStatement extends BabelNode {
    type: "TryStatement";
    body?: ?BabelNodeBlockStatement;
    handler?: ?BabelNodeCatchClause;
    finalizer?: ?BabelNodeBlockStatement;
    block: BabelNodeBlockStatement;
  }

  declare class BabelNodeUnaryExpression extends BabelNode {
    type: "UnaryExpression";
    prefix?: boolean;
    argument: BabelNodeExpression;
    operator: BabelUnaryOperator;
  }

  declare class BabelNodeUpdateExpression extends BabelNode {
    type: "UpdateExpression";
    prefix?: boolean;
    argument: BabelNodeExpression;
    operator: BabelUpdateOperator;
  }

  declare class BabelNodeVariableDeclaration extends BabelNode {
    type: "VariableDeclaration";
    kind: BabelVariableKind;
    declarations: Array<BabelNodeVariableDeclarator>;
  }

  declare class BabelNodeVariableDeclarator extends BabelNode {
    type: "VariableDeclarator";
    id: BabelNodeLVal;
    init?: ?BabelNodeExpression;
  }

  declare class BabelNodeWhileStatement extends BabelNode {
    type: "WhileStatement";
    test: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeWithStatement extends BabelNode {
    type: "WithStatement";
    object: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeAssignmentPattern extends BabelNode {
    type: "AssignmentPattern";
    left: BabelNodeIdentifier;
    right: BabelNodeExpression;
    decorators?: any;
  }

  declare class BabelNodeArrayPattern extends BabelNode {
    type: "ArrayPattern";
    elements: any;
    decorators?: any;
    typeAnnotation: any;
  }

  declare class BabelNodeArrowFunctionExpression extends BabelNode {
    type: "ArrowFunctionExpression";
    body: BabelNodeBlockStatement | BabelNodeExpression;
    expression: boolean;
    id?: ?BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    generator?: boolean;
    async: boolean;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeClassBody extends BabelNode {
    type: "ClassBody";
    body: Array<BabelNodeClassMethod | BabelNodeClassProperty>;
  }

  declare class BabelNodeClassDeclaration extends BabelNode {
    type: "ClassDeclaration";
    id: BabelNodeIdentifier;
    body: BabelNodeClassBody;
    superClass?: ?BabelNodeExpression;
    decorators: Array<BabelNodeDecorator>;
    mixins?: any;
    typeParameters?: any;
    superTypeParameters?: any;
  }

  declare class BabelNodeClassExpression extends BabelNode {
    type: "ClassExpression";
    id?: ?BabelNodeIdentifier;
    body: BabelNodeClassBody;
    superClass?: ?BabelNodeExpression;
    decorators: any;
    mixins?: any;
    typeParameters?: any;
    superTypeParameters?: any;
  }

  declare class BabelNodeExportAllDeclaration extends BabelNode {
    type: "ExportAllDeclaration";
    source: BabelNodeStringLiteral;
  }

  declare class BabelNodeExportDefaultDeclaration extends BabelNode {
    type: "ExportDefaultDeclaration";
    declaration: BabelNodeFunctionDeclaration | BabelNodeClassDeclaration | BabelNodeExpression;
  }

  declare class BabelNodeExportNamedDeclaration extends BabelNode {
    type: "ExportNamedDeclaration";
    declaration?: ?BabelNodeDeclaration;
    specifiers: Array<BabelNodeExportSpecifier>;
    source?: ?BabelNodeStringLiteral;
  }

  declare class BabelNodeExportSpecifier extends BabelNode {
    type: "ExportSpecifier";
    local: BabelNodeIdentifier;
    exported: BabelNodeIdentifier;
  }

  declare class BabelNodeForOfStatement extends BabelNode {
    type: "ForOfStatement";
    left: BabelNodeVariableDeclaration | BabelNodeLVal;
    right: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeImportDeclaration extends BabelNode {
    type: "ImportDeclaration";
    specifiers: [BabelNodeImportSpecifier | BabelNodeImportDefaultSpecifier | BabelNodeImportNamespaceSpecifier];
    source: BabelNodeStringLiteral;
  }

  declare class BabelNodeImportDefaultSpecifier extends BabelNode {
    type: "ImportDefaultSpecifier";
    local: BabelNodeIdentifier;
  }

  declare class BabelNodeImportNamespaceSpecifier extends BabelNode {
    type: "ImportNamespaceSpecifier";
    local: BabelNodeIdentifier;
  }

  declare class BabelNodeImportSpecifier extends BabelNode {
    type: "ImportSpecifier";
    local: BabelNodeIdentifier;
    imported: BabelNodeIdentifier;
  }

  declare class BabelNodeMetaProperty extends BabelNode {
    type: "MetaProperty";
    meta: BabelNodeIdentifier;
    property: BabelNodeIdentifier;
  }

  declare class BabelNodeClassMethod extends BabelNode {
    type: "ClassMethod";
    kind?: any;
    computed?: boolean;
    key: any;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator?: boolean;
    async?: boolean;
    decorators: Array<BabelNodeDecorator>;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeObjectPattern extends BabelNode {
    type: "ObjectPattern";
    properties: any;
    decorators?: any;
    typeAnnotation: any;
  }

  declare class BabelNodeSpreadElement extends BabelNode {
    type: "SpreadElement";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeSuper extends BabelNode {
    type: "Super";
  }

  declare class BabelNodeTaggedTemplateExpression extends BabelNode {
    type: "TaggedTemplateExpression";
    tag: BabelNodeExpression;
    quasi: BabelNodeTemplateLiteral;
  }

  declare class BabelNodeTemplateElement extends BabelNode {
    type: "TemplateElement";
    value: { cooked: string, raw: string };
    tail: boolean;
  }

  declare class BabelNodeTemplateLiteral extends BabelNode {
    type: "TemplateLiteral";
    quasis: Array<BabelNodeTemplateElement>;
    expressions: Array<BabelNodeExpression>;
  }

  declare class BabelNodeYieldExpression extends BabelNode {
    type: "YieldExpression";
    delegate: boolean;
    argument?: ?BabelNodeExpression;
  }

  declare class BabelNodeAnyTypeAnnotation extends BabelNode {
    type: "AnyTypeAnnotation";
  }

  declare class BabelNodeArrayTypeAnnotation extends BabelNode {
    type: "ArrayTypeAnnotation";
    elementType: any;
  }

  declare class BabelNodeBooleanTypeAnnotation extends BabelNode {
    type: "BooleanTypeAnnotation";
  }

  declare class BabelNodeBooleanLiteralTypeAnnotation extends BabelNode {
    type: "BooleanLiteralTypeAnnotation";
  }

  declare class BabelNodeNullLiteralTypeAnnotation extends BabelNode {
    type: "NullLiteralTypeAnnotation";
  }

  declare class BabelNodeClassImplements extends BabelNode {
    type: "ClassImplements";
    id: any;
    typeParameters: any;
  }

  declare class BabelNodeClassProperty extends BabelNode {
    type: "ClassProperty";
    computed: boolean;
    key: BabelNodeIdentifier;
    value: BabelNodeExpression;
    typeAnnotation: any;
    decorators: Array<BabelNodeDecorator>;
  }

  declare class BabelNodeDeclareClass extends BabelNode {
    type: "DeclareClass";
    id: any;
    typeParameters: any;
    body: any;
  }

  declare class BabelNodeDeclareFunction extends BabelNode {
    type: "DeclareFunction";
    id: any;
  }

  declare class BabelNodeDeclareInterface extends BabelNode {
    type: "DeclareInterface";
    id: any;
    typeParameters: any;
    body: any;
  }

  declare class BabelNodeDeclareModule extends BabelNode {
    type: "DeclareModule";
    id: any;
    body: any;
  }

  declare class BabelNodeDeclareModuleExports extends BabelNode {
    type: "DeclareModuleExports";
    typeAnnotation: any;
  }

  declare class BabelNodeDeclareTypeAlias extends BabelNode {
    type: "DeclareTypeAlias";
    id: any;
    typeParameters: any;
    right: any;
  }

  declare class BabelNodeDeclareVariable extends BabelNode {
    type: "DeclareVariable";
    id: any;
  }

  declare class BabelNodeExistentialTypeParam extends BabelNode {
    type: "ExistentialTypeParam";
  }

  declare class BabelNodeFunctionTypeAnnotation extends BabelNode {
    type: "FunctionTypeAnnotation";
    typeParameters: any;
    params: any;
    rest: any;
    returnType: any;
  }

  declare class BabelNodeFunctionTypeParam extends BabelNode {
    type: "FunctionTypeParam";
    name: any;
    typeAnnotation: any;
  }

  declare class BabelNodeGenericTypeAnnotation extends BabelNode {
    type: "GenericTypeAnnotation";
    id: any;
    typeParameters: any;
  }

  declare class BabelNodeInterfaceExtends extends BabelNode {
    type: "InterfaceExtends";
    id: any;
    typeParameters: any;
  }

  declare class BabelNodeInterfaceDeclaration extends BabelNode {
    type: "InterfaceDeclaration";
    id: any;
    typeParameters: any;
    body: any;
  }

  declare class BabelNodeIntersectionTypeAnnotation extends BabelNode {
    type: "IntersectionTypeAnnotation";
    types: any;
  }

  declare class BabelNodeMixedTypeAnnotation extends BabelNode {
    type: "MixedTypeAnnotation";
  }

  declare class BabelNodeEmptyTypeAnnotation extends BabelNode {
    type: "EmptyTypeAnnotation";
  }

  declare class BabelNodeNullableTypeAnnotation extends BabelNode {
    type: "NullableTypeAnnotation";
    typeAnnotation: any;
  }

  declare class BabelNodeNumericLiteralTypeAnnotation extends BabelNode {
    type: "NumericLiteralTypeAnnotation";
  }

  declare class BabelNodeNumberTypeAnnotation extends BabelNode {
    type: "NumberTypeAnnotation";
  }

  declare class BabelNodeStringLiteralTypeAnnotation extends BabelNode {
    type: "StringLiteralTypeAnnotation";
  }

  declare class BabelNodeStringTypeAnnotation extends BabelNode {
    type: "StringTypeAnnotation";
  }

  declare class BabelNodeThisTypeAnnotation extends BabelNode {
    type: "ThisTypeAnnotation";
  }

  declare class BabelNodeTupleTypeAnnotation extends BabelNode {
    type: "TupleTypeAnnotation";
    types: any;
  }

  declare class BabelNodeTypeofTypeAnnotation extends BabelNode {
    type: "TypeofTypeAnnotation";
    argument: any;
  }

  declare class BabelNodeTypeAlias extends BabelNode {
    type: "TypeAlias";
    id: any;
    typeParameters: any;
    right: any;
  }

  declare class BabelNodeTypeAnnotation extends BabelNode {
    type: "TypeAnnotation";
    typeAnnotation: any;
  }

  declare class BabelNodeTypeCastExpression extends BabelNode {
    type: "TypeCastExpression";
    expression: any;
    typeAnnotation: any;
  }

  declare class BabelNodeTypeParameter extends BabelNode {
    type: "TypeParameter";
    bound: any;
  }

  declare class BabelNodeTypeParameterDeclaration extends BabelNode {
    type: "TypeParameterDeclaration";
    params: any;
  }

  declare class BabelNodeTypeParameterInstantiation extends BabelNode {
    type: "TypeParameterInstantiation";
    params: any;
  }

  declare class BabelNodeObjectTypeAnnotation extends BabelNode {
    type: "ObjectTypeAnnotation";
    properties: any;
    indexers: any;
    callProperties: any;
  }

  declare class BabelNodeObjectTypeCallProperty extends BabelNode {
    type: "ObjectTypeCallProperty";
    value: any;
  }

  declare class BabelNodeObjectTypeIndexer extends BabelNode {
    type: "ObjectTypeIndexer";
    id: any;
    key: any;
    value: any;
  }

  declare class BabelNodeObjectTypeProperty extends BabelNode {
    type: "ObjectTypeProperty";
    key: any;
    value: any;
  }

  declare class BabelNodeQualifiedTypeIdentifier extends BabelNode {
    type: "QualifiedTypeIdentifier";
    id: any;
    qualification: any;
  }

  declare class BabelNodeUnionTypeAnnotation extends BabelNode {
    type: "UnionTypeAnnotation";
    types: any;
  }

  declare class BabelNodeVoidTypeAnnotation extends BabelNode {
    type: "VoidTypeAnnotation";
  }

  declare class BabelNodeJSXAttribute extends BabelNode {
    type: "JSXAttribute";
    name: BabelNodeJSXIdentifier | BabelNodeJSXNamespacedName;
    value?: ?BabelNodeJSXElement | BabelNodeStringLiteral | BabelNodeJSXExpressionContainer;
  }

  declare class BabelNodeJSXClosingElement extends BabelNode {
    type: "JSXClosingElement";
    name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression;
  }

  declare class BabelNodeJSXElement extends BabelNode {
    type: "JSXElement";
    openingElement: BabelNodeJSXOpeningElement;
    closingElement?: ?BabelNodeJSXClosingElement;
    children: any;
    selfClosing: any;
  }

  declare class BabelNodeJSXEmptyExpression extends BabelNode {
    type: "JSXEmptyExpression";
  }

  declare class BabelNodeJSXExpressionContainer extends BabelNode {
    type: "JSXExpressionContainer";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeJSXIdentifier extends BabelNode {
    type: "JSXIdentifier";
    name: string;
  }

  declare class BabelNodeJSXMemberExpression extends BabelNode {
    type: "JSXMemberExpression";
    object: BabelNodeJSXMemberExpression | BabelNodeJSXIdentifier;
    property: BabelNodeJSXIdentifier;
  }

  declare class BabelNodeJSXNamespacedName extends BabelNode {
    type: "JSXNamespacedName";
    namespace: BabelNodeJSXIdentifier;
    name: BabelNodeJSXIdentifier;
  }

  declare class BabelNodeJSXOpeningElement extends BabelNode {
    type: "JSXOpeningElement";
    name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression;
    selfClosing?: boolean;
    attributes: any;
  }

  declare class BabelNodeJSXSpreadAttribute extends BabelNode {
    type: "JSXSpreadAttribute";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeJSXText extends BabelNode {
    type: "JSXText";
    value: string;
  }

  declare class BabelNodeNoop extends BabelNode {
    type: "Noop";
  }

  declare class BabelNodeParenthesizedExpression extends BabelNode {
    type: "ParenthesizedExpression";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeAwaitExpression extends BabelNode {
    type: "AwaitExpression";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeForAwaitStatement extends BabelNode {
    type: "ForAwaitStatement";
    left: BabelNodeVariableDeclaration | BabelNodeLVal;
    right: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeBindExpression extends BabelNode {
    type: "BindExpression";
    object: any;
    callee: any;
  }

  declare class BabelNodeDecorator extends BabelNode {
    type: "Decorator";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeDoExpression extends BabelNode {
    type: "DoExpression";
    body: BabelNodeBlockStatement;
  }

  declare class BabelNodeExportDefaultSpecifier extends BabelNode {
    type: "ExportDefaultSpecifier";
    exported: BabelNodeIdentifier;
  }

  declare class BabelNodeExportNamespaceSpecifier extends BabelNode {
    type: "ExportNamespaceSpecifier";
    exported: BabelNodeIdentifier;
  }

  declare class BabelNodeRestProperty extends BabelNode {
    type: "RestProperty";
    argument: BabelNodeLVal;
  }

  declare type BabelNodeExpression = BabelNodeArrayExpression | BabelNodeAssignmentExpression | BabelNodeBinaryExpression | BabelNodeCallExpression | BabelNodeConditionalExpression | BabelNodeFunctionExpression | BabelNodeIdentifier | BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeRegExpLiteral | BabelNodeLogicalExpression | BabelNodeMemberExpression | BabelNodeNewExpression | BabelNodeObjectExpression | BabelNodeSequenceExpression | BabelNodeThisExpression | BabelNodeUnaryExpression | BabelNodeUpdateExpression | BabelNodeArrowFunctionExpression | BabelNodeClassExpression | BabelNodeMetaProperty | BabelNodeSuper | BabelNodeTaggedTemplateExpression | BabelNodeTemplateLiteral | BabelNodeYieldExpression | BabelNodeTypeCastExpression | BabelNodeJSXElement | BabelNodeJSXEmptyExpression | BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression | BabelNodeParenthesizedExpression | BabelNodeAwaitExpression | BabelNodeBindExpression | BabelNodeDoExpression;
  declare type BabelNodeBinary = BabelNodeBinaryExpression | BabelNodeLogicalExpression;
  declare type BabelNodeScopable = BabelNodeBlockStatement | BabelNodeCatchClause | BabelNodeDoWhileStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeProgram | BabelNodeObjectMethod | BabelNodeSwitchStatement | BabelNodeWhileStatement | BabelNodeArrowFunctionExpression | BabelNodeClassDeclaration | BabelNodeClassExpression | BabelNodeForOfStatement | BabelNodeClassMethod | BabelNodeForAwaitStatement;
  declare type BabelNodeBlockParent = BabelNodeBlockStatement | BabelNodeDoWhileStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeProgram | BabelNodeObjectMethod | BabelNodeSwitchStatement | BabelNodeWhileStatement | BabelNodeArrowFunctionExpression | BabelNodeForOfStatement | BabelNodeClassMethod | BabelNodeForAwaitStatement;
  declare type BabelNodeBlock = BabelNodeBlockStatement | BabelNodeProgram;
  declare type BabelNodeStatement = BabelNodeBlockStatement | BabelNodeBreakStatement | BabelNodeContinueStatement | BabelNodeDebuggerStatement | BabelNodeDoWhileStatement | BabelNodeEmptyStatement | BabelNodeExpressionStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeFunctionDeclaration | BabelNodeIfStatement | BabelNodeLabeledStatement | BabelNodeReturnStatement | BabelNodeSwitchStatement | BabelNodeThrowStatement | BabelNodeTryStatement | BabelNodeVariableDeclaration | BabelNodeWhileStatement | BabelNodeWithStatement | BabelNodeClassDeclaration | BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration | BabelNodeForOfStatement | BabelNodeImportDeclaration | BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeInterfaceDeclaration | BabelNodeTypeAlias | BabelNodeForAwaitStatement;
  declare type BabelNodeTerminatorless = BabelNodeBreakStatement | BabelNodeContinueStatement | BabelNodeReturnStatement | BabelNodeThrowStatement | BabelNodeYieldExpression | BabelNodeAwaitExpression;
  declare type BabelNodeCompletionStatement = BabelNodeBreakStatement | BabelNodeContinueStatement | BabelNodeReturnStatement | BabelNodeThrowStatement;
  declare type BabelNodeConditional = BabelNodeConditionalExpression | BabelNodeIfStatement;
  declare type BabelNodeLoop = BabelNodeDoWhileStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeWhileStatement | BabelNodeForOfStatement | BabelNodeForAwaitStatement;
  declare type BabelNodeWhile = BabelNodeDoWhileStatement | BabelNodeWhileStatement;
  declare type BabelNodeExpressionWrapper = BabelNodeExpressionStatement | BabelNodeTypeCastExpression | BabelNodeParenthesizedExpression;
  declare type BabelNodeFor = BabelNodeForInStatement | BabelNodeForStatement | BabelNodeForOfStatement | BabelNodeForAwaitStatement;
  declare type BabelNodeForXStatement = BabelNodeForInStatement | BabelNodeForOfStatement | BabelNodeForAwaitStatement;
  declare type BabelNodeFunction = BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeObjectMethod | BabelNodeArrowFunctionExpression | BabelNodeClassMethod;
  declare type BabelNodeFunctionParent = BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeProgram | BabelNodeObjectMethod | BabelNodeArrowFunctionExpression | BabelNodeClassMethod;
  declare type BabelNodePureish = BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeArrowFunctionExpression | BabelNodeClassDeclaration | BabelNodeClassExpression;
  declare type BabelNodeDeclaration = BabelNodeFunctionDeclaration | BabelNodeVariableDeclaration | BabelNodeClassDeclaration | BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration | BabelNodeImportDeclaration | BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeInterfaceDeclaration | BabelNodeTypeAlias;
  declare type BabelNodeLVal = BabelNodeIdentifier | BabelNodeMemberExpression | BabelNodeRestElement | BabelNodeAssignmentPattern | BabelNodeArrayPattern | BabelNodeObjectPattern;
  declare type BabelNodeLiteral = BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeRegExpLiteral | BabelNodeTemplateLiteral;
  declare type BabelNodeImmutable = BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeJSXAttribute | BabelNodeJSXClosingElement | BabelNodeJSXElement | BabelNodeJSXExpressionContainer | BabelNodeJSXOpeningElement | BabelNodeJSXText;
  declare type BabelNodeUserWhitespacable = BabelNodeObjectMethod | BabelNodeObjectProperty | BabelNodeObjectTypeCallProperty | BabelNodeObjectTypeIndexer | BabelNodeObjectTypeProperty;
  declare type BabelNodeMethod = BabelNodeObjectMethod | BabelNodeClassMethod;
  declare type BabelNodeObjectMember = BabelNodeObjectMethod | BabelNodeObjectProperty;
  declare type BabelNodeProperty = BabelNodeObjectProperty | BabelNodeClassProperty;
  declare type BabelNodeUnaryLike = BabelNodeUnaryExpression | BabelNodeSpreadElement | BabelNodeRestProperty;
  declare type BabelNodePattern = BabelNodeAssignmentPattern | BabelNodeArrayPattern | BabelNodeObjectPattern | BabelNodeRestElement;
  declare type BabelNodeClass = BabelNodeClassDeclaration | BabelNodeClassExpression;
  declare type BabelNodeModuleDeclaration = BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration | BabelNodeImportDeclaration;
  declare type BabelNodeExportDeclaration = BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration;
  declare type BabelNodeModuleSpecifier = BabelNodeExportSpecifier | BabelNodeImportDefaultSpecifier | BabelNodeImportNamespaceSpecifier | BabelNodeImportSpecifier | BabelNodeExportDefaultSpecifier | BabelNodeExportNamespaceSpecifier;
  declare type BabelNodeFlow = BabelNodeAnyTypeAnnotation | BabelNodeArrayTypeAnnotation | BabelNodeBooleanTypeAnnotation | BabelNodeBooleanLiteralTypeAnnotation | BabelNodeNullLiteralTypeAnnotation | BabelNodeClassImplements | BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeExistentialTypeParam | BabelNodeFunctionTypeAnnotation | BabelNodeFunctionTypeParam | BabelNodeGenericTypeAnnotation | BabelNodeInterfaceExtends | BabelNodeInterfaceDeclaration | BabelNodeIntersectionTypeAnnotation | BabelNodeMixedTypeAnnotation | BabelNodeEmptyTypeAnnotation | BabelNodeNullableTypeAnnotation | BabelNodeNumericLiteralTypeAnnotation | BabelNodeNumberTypeAnnotation | BabelNodeStringLiteralTypeAnnotation | BabelNodeStringTypeAnnotation | BabelNodeThisTypeAnnotation | BabelNodeTupleTypeAnnotation | BabelNodeTypeofTypeAnnotation | BabelNodeTypeAlias | BabelNodeTypeAnnotation | BabelNodeTypeCastExpression | BabelNodeTypeParameter | BabelNodeTypeParameterDeclaration | BabelNodeTypeParameterInstantiation | BabelNodeObjectTypeAnnotation | BabelNodeObjectTypeCallProperty | BabelNodeObjectTypeIndexer | BabelNodeObjectTypeProperty | BabelNodeQualifiedTypeIdentifier | BabelNodeUnionTypeAnnotation | BabelNodeVoidTypeAnnotation;
  declare type BabelNodeFlowBaseAnnotation = BabelNodeAnyTypeAnnotation | BabelNodeBooleanTypeAnnotation | BabelNodeNullLiteralTypeAnnotation | BabelNodeMixedTypeAnnotation | BabelNodeEmptyTypeAnnotation | BabelNodeNumberTypeAnnotation | BabelNodeStringTypeAnnotation | BabelNodeThisTypeAnnotation | BabelNodeVoidTypeAnnotation;
  declare type BabelNodeFlowDeclaration = BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeInterfaceDeclaration | BabelNodeTypeAlias;
  declare type BabelNodeJSX = BabelNodeJSXAttribute | BabelNodeJSXClosingElement | BabelNodeJSXElement | BabelNodeJSXEmptyExpression | BabelNodeJSXExpressionContainer | BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression | BabelNodeJSXNamespacedName | BabelNodeJSXOpeningElement | BabelNodeJSXSpreadAttribute | BabelNodeJSXText;

  declare function anyTypeAnnotation(): BabelNodeAnyTypeAnnotation;
  declare function arrayExpression(elements: Array<null | BabelNodeExpression | BabelNodeSpreadElement>): BabelNodeArrayExpression;
  declare function arrayPattern(elements: Array<BabelNodeExpression>, typeAnnotation: any, decorators?: Array<BabelNodeDecorator>): BabelNodeArrayPattern;
  declare function arrayTypeAnnotation(elementType: any): BabelNodeArrayTypeAnnotation;
  declare function arrowFunctionExpression(params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement | BabelNodeExpression, async?: boolean, returnType?: any, typeParameters?: any): BabelNodeArrowFunctionExpression;
  declare function assignmentExpression(operator: BabelAssignmentOperator, left: BabelNodeLVal, right: BabelNodeExpression): BabelNodeAssignmentExpression;
  declare function assignmentPattern(left: BabelNodeIdentifier, right: BabelNodeExpression, decorators?: any): BabelNodeAssignmentPattern;
  declare function awaitExpression(argument: BabelNodeExpression): BabelNodeAwaitExpression;
  declare function binaryExpression(operator: BabelBinaryOperator, left: BabelNodeExpression, right: BabelNodeExpression): BabelNodeBinaryExpression;
  declare function bindExpression(object: any, callee: any): BabelNodeBindExpression;
  declare function blockStatement(body: Array<BabelNodeStatement>, directives?: Array<BabelNodeDirective>): BabelNodeBlockStatement;
  declare function booleanLiteral(value: boolean): BabelNodeBooleanLiteral;
  declare function booleanLiteralTypeAnnotation(): BabelNodeBooleanLiteralTypeAnnotation;
  declare function booleanTypeAnnotation(): BabelNodeBooleanTypeAnnotation;
  declare function breakStatement(label?: ?BabelNodeIdentifier): BabelNodeBreakStatement;
  declare function callExpression(callee: BabelNodeExpression, _arguments: Array<BabelNodeExpression | BabelNodeSpreadElement>): BabelNodeCallExpression;
  declare function catchClause(param: BabelNodeIdentifier, body: BabelNodeBlockStatement): BabelNodeCatchClause;
  declare function classBody(body: Array<BabelNodeClassMethod | BabelNodeClassProperty>): BabelNodeClassBody;
  declare function classDeclaration(id: BabelNodeIdentifier, superClass?: ?BabelNodeExpression, body: BabelNodeClassBody, decorators: Array<BabelNodeDecorator>, mixins?: any, typeParameters?: any, superTypeParameters?: any, _implements?: any): BabelNodeClassDeclaration;
  declare function classExpression(id?: ?BabelNodeIdentifier,  superClass?: ?BabelNodeExpression, body: BabelNodeClassBody, decorators: Array<BabelNodeDecorator>, _implements?: any, mixins?: any, superTypeParameters?: any, typeParameters?: any): BabelNodeClassExpression;
  declare function classImplements(id: any, typeParameters: any): BabelNodeClassImplements;
  declare function classMethod(kind: ?("get" | "set" | "method" | "constructor"), key: BabelNodeExpression | BabelNodeIdentifier | BabelNodeLiteral, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, computed?: boolean, _static?: boolean, async?: boolean, decorators?: any, generator?: boolean, returnType?: any, typeParameters?: any): BabelNodeClassMethod;
  declare function classProperty(key: any, value: any, typeAnnotation: any, decorators: any, computed?: boolean): BabelNodeClassProperty;
  declare function conditionalExpression(test: BabelNodeExpression, consequent: BabelNodeExpression, alternate: BabelNodeExpression): BabelNodeConditionalExpression;
  declare function continueStatement(label?: ?BabelNodeIdentifier): BabelNodeContinueStatement;
  declare function debuggerStatement(): BabelNodeDebuggerStatement;
  declare function declareClass(id: any, typeParameters: any, _extends: any, body: any): BabelNodeDeclareClass;
  declare function declareFunction(id: any): BabelNodeDeclareFunction;
  declare function declareInterface(id: any, typeParameters: any, _extends: any, body: any): BabelNodeDeclareInterface;
  declare function declareModule(id: any, body: any): BabelNodeDeclareModule;
  declare function declareModuleExports(typeAnnotation: any): BabelNodeDeclareModuleExports;
  declare function declareTypeAlias(id: any, typeParameters: any, right: any): BabelNodeDeclareTypeAlias;
  declare function declareVariable(id: any): BabelNodeDeclareVariable;
  declare function decorator(expression: BabelNodeExpression): BabelNodeDecorator;
  declare function directive(value: BabelNodeDirectiveLiteral): BabelNodeDirective;
  declare function directiveLiteral(value: string): BabelNodeDirectiveLiteral;
  declare function doExpression(body: BabelNodeBlockStatement): BabelNodeDoExpression;
  declare function doWhileStatement(test: BabelNodeExpression, body: BabelNodeStatement): BabelNodeDoWhileStatement;
  declare function emptyStatement(): BabelNodeEmptyStatement;
  declare function emptyTypeAnnotation(): BabelNodeEmptyTypeAnnotation;
  declare function existentialTypeParam(): BabelNodeExistentialTypeParam;
  declare function exportAllDeclaration(source: BabelNodeStringLiteral): BabelNodeExportAllDeclaration;
  declare function exportDefaultDeclaration(declaration: BabelNodeFunctionDeclaration | BabelNodeClassDeclaration | BabelNodeExpression): BabelNodeExportDefaultDeclaration;
  declare function exportDefaultSpecifier(exported: BabelNodeIdentifier): BabelNodeExportDefaultSpecifier;
  declare function exportNamedDeclaration(declaration?: ?BabelNodeDeclaration, specifiers: Array<BabelNodeExportSpecifier>, source?: ?BabelNodeStringLiteral): BabelNodeExportNamedDeclaration;
  declare function exportNamespaceSpecifier(exported: BabelNodeIdentifier): BabelNodeExportNamespaceSpecifier;
  declare function exportSpecifier(local: BabelNodeIdentifier, exported: BabelNodeIdentifier): BabelNodeExportSpecifier;
  declare function expressionStatement(expression: BabelNodeExpression): BabelNodeExpressionStatement;
  declare function file(program: BabelNodeProgram, comments: any, tokens: any): BabelNodeFile;
  declare function forAwaitStatement(left: BabelNodeVariableDeclaration | BabelNodeLVal, right: BabelNodeExpression, body: BabelNodeStatement): BabelNodeForAwaitStatement;
  declare function forInStatement(left: BabelNodeVariableDeclaration | BabelNodeLVal, right: BabelNodeExpression, body: BabelNodeStatement): BabelNodeForInStatement;
  declare function forOfStatement(left: BabelNodeVariableDeclaration | BabelNodeLVal, right: BabelNodeExpression, body: BabelNodeStatement): BabelNodeForOfStatement;
  declare function forStatement(init?: ?BabelNodeVariableDeclaration | BabelNodeExpression, test?: ?BabelNodeExpression, update?: ?BabelNodeExpression, body: BabelNodeStatement): BabelNodeForStatement;
  declare function functionDeclaration(id: BabelNodeIdentifier, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, generator?: boolean, async?: boolean, returnType?: any, typeParameters?: any): BabelNodeFunctionDeclaration;
  declare function functionExpression(id?: ?BabelNodeIdentifier, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, generator?: boolean, async?: boolean, returnType?: any, typeParameters?: any): BabelNodeFunctionExpression;
  declare function functionTypeAnnotation(typeParameters: any, params: any, rest: any, returnType: any): BabelNodeFunctionTypeAnnotation;
  declare function functionTypeParam(name: any, typeAnnotation: any): BabelNodeFunctionTypeParam;
  declare function genericTypeAnnotation(id: any, typeParameters: any): BabelNodeGenericTypeAnnotation;
  declare function identifier(name: string, decorators?: Array<BabelNodeDecorator>, typeAnnotation?: any): BabelNodeIdentifier;
  declare function ifStatement(test: BabelNodeExpression, consequent: BabelNodeStatement, alternate?: ?BabelNodeStatement): BabelNodeIfStatement;
  declare function importDeclaration(specifiers: any, source: BabelNodeStringLiteral): BabelNodeImportDeclaration;
  declare function importDefaultSpecifier(local: BabelNodeIdentifier): BabelNodeImportDefaultSpecifier;
  declare function importNamespaceSpecifier(local: BabelNodeIdentifier): BabelNodeImportNamespaceSpecifier;
  declare function importSpecifier(local: BabelNodeIdentifier, imported: BabelNodeIdentifier): BabelNodeImportSpecifier;
  declare function interfaceDeclaration(id: any, typeParameters: any, _extends: any, body: any): BabelNodeInterfaceDeclaration;
  declare function interfaceExtends(id: any, typeParameters: any): BabelNodeInterfaceExtends;
  declare function intersectionTypeAnnotation(types: any): BabelNodeIntersectionTypeAnnotation;
  declare function jSXAttribute(name: BabelNodeJSXIdentifier | BabelNodeJSXNamespacedName, value?: ?BabelNodeJSXElement | BabelNodeStringLiteral | BabelNodeJSXExpressionContainer): BabelNodeJSXAttribute;
  declare function jSXClosingElement(name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression): BabelNodeJSXClosingElement;
  declare function jSXElement(openingElement: BabelNodeJSXOpeningElement, closingElement?: ?BabelNodeJSXClosingElement, children: any, selfClosing: any): BabelNodeJSXElement;
  declare function jSXEmptyExpression(): BabelNodeJSXEmptyExpression;
  declare function jSXExpressionContainer(expression: BabelNodeExpression): BabelNodeJSXExpressionContainer;
  declare function jSXIdentifier(name: string): BabelNodeJSXIdentifier;
  declare function jSXMemberExpression(object: BabelNodeJSXMemberExpression | BabelNodeJSXIdentifier, property: BabelNodeJSXIdentifier): BabelNodeJSXMemberExpression;
  declare function jSXNamespacedName(namespace: BabelNodeJSXIdentifier, name: BabelNodeJSXIdentifier): BabelNodeJSXNamespacedName;
  declare function jSXOpeningElement(name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression, selfClosing?: boolean, attributes: any): BabelNodeJSXOpeningElement;
  declare function jSXSpreadAttribute(argument: BabelNodeExpression): BabelNodeJSXSpreadAttribute;
  declare function jSXText(value: string): BabelNodeJSXText;
  declare function labeledStatement(label: BabelNodeIdentifier, body: BabelNodeStatement): BabelNodeLabeledStatement;
  declare function logicalExpression(operator: BabelLogicalOperator, left: BabelNodeExpression, right: BabelNodeExpression): BabelNodeLogicalExpression;
  declare function memberExpression(object: BabelNodeExpression, property: BabelNodeExpression | BabelNodeIdentifier, computed?: boolean): BabelNodeMemberExpression;
  declare function metaProperty(meta: string, property: string): BabelNodeMetaProperty;
  declare function mixedTypeAnnotation(): BabelNodeMixedTypeAnnotation;
  declare function newExpression(callee: BabelNodeExpression, _arguments: Array<BabelNodeExpression>): BabelNodeNewExpression;
  declare function noop(): BabelNodeNoop;
  declare function nullLiteral(): BabelNodeNullLiteral;
  declare function nullLiteralTypeAnnotation(): BabelNodeNullLiteralTypeAnnotation;
  declare function nullableTypeAnnotation(typeAnnotation: any): BabelNodeNullableTypeAnnotation;
  declare function numberTypeAnnotation(): BabelNodeNumberTypeAnnotation;
  declare function numericLiteral(value: number): BabelNodeNumericLiteral;
  declare function numericLiteralTypeAnnotation(): BabelNodeNumericLiteralTypeAnnotation;
  declare function objectExpression(properties: Array<BabelNodeObjectMethod | BabelNodeObjectProperty | BabelNodeSpreadElement>): BabelNodeObjectExpression;
  declare function objectMethod(kind: BabelObjectMethodKind, key: BabelNodeExpression | BabelNodeIdentifier | BabelNodeLiteral, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, computed?: boolean, async?: boolean, decorators?: any, generator?: boolean, returnType?: any, typeParameters?: any): BabelNodeObjectMethod;
  declare function objectPattern(properties: Array<BabelNodeRestProperty | BabelNodeProperty>, typeAnnotation: any, decorators?: Array<BabelNodeDecorator>): BabelNodeObjectPattern;
  declare function objectProperty(key: BabelNodeExpression | BabelNodeIdentifier | BabelNodeLiteral, value: BabelNodeExpression, computed?: boolean, shorthand?: boolean, decorators: ?Array<BabelNodeDecorator>): BabelNodeObjectProperty;
  declare function objectTypeAnnotation(properties: any, indexers: any, callProperties: any): BabelNodeObjectTypeAnnotation;
  declare function objectTypeCallProperty(value: any): BabelNodeObjectTypeCallProperty;
  declare function objectTypeIndexer(id: any, key: any, value: any): BabelNodeObjectTypeIndexer;
  declare function objectTypeProperty(key: any, value: any): BabelNodeObjectTypeProperty;
  declare function parenthesizedExpression(expression: BabelNodeExpression): BabelNodeParenthesizedExpression;
  declare function program(body: Array<BabelNodeStatement>, directives?: Array<BabelNodeDirective>): BabelNodeProgram;
  declare function qualifiedTypeIdentifier(id: any, qualification: any): BabelNodeQualifiedTypeIdentifier;
  declare function regExpLiteral(pattern: string, flags?: string): BabelNodeRegExpLiteral;
  declare function restElement(argument: BabelNodeLVal, typeAnnotation: any, decorators?: any): BabelNodeRestElement;
  declare function restProperty(argument: BabelNodeLVal): BabelNodeRestProperty;
  declare function returnStatement(argument?: ?BabelNodeExpression): BabelNodeReturnStatement;
  declare function sequenceExpression(expressions: Array<BabelNodeExpression>): BabelNodeSequenceExpression;
  declare function spreadElement(argument: BabelNodeExpression): BabelNodeSpreadElement;
  declare function stringLiteral(value: string): BabelNodeStringLiteral;
  declare function stringLiteralTypeAnnotation(): BabelNodeStringLiteralTypeAnnotation;
  declare function stringTypeAnnotation(): BabelNodeStringTypeAnnotation;
  declare function switchCase(test?: ?BabelNodeExpression, consequent: Array<BabelNodeStatement>): BabelNodeSwitchCase;
  declare function switchStatement(discriminant: BabelNodeExpression, cases: Array<BabelNodeSwitchCase>): BabelNodeSwitchStatement;
  declare function taggedTemplateExpression(tag: BabelNodeExpression, quasi: BabelNodeTemplateLiteral): BabelNodeTaggedTemplateExpression;
  declare function templateElement(value: any, tail?: boolean): BabelNodeTemplateElement;
  declare function templateLiteral(quasis: Array<BabelNodeTemplateElement>, expressions: Array<BabelNodeExpression>): BabelNodeTemplateLiteral;
  declare function thisExpression(): BabelNodeThisExpression;
  declare function thisTypeAnnotation(): BabelNodeThisTypeAnnotation;
  declare function throwStatement(argument: BabelNodeExpression): BabelNodeThrowStatement;
  declare function tryStatement(block: any, handler?: any, finalizer?: ?BabelNodeBlockStatement, body?: ?BabelNodeBlockStatement): BabelNodeTryStatement;
  declare function tupleTypeAnnotation(types: any): BabelNodeTupleTypeAnnotation;
  declare function typeAlias(id: any, typeParameters: any, right: any): BabelNodeTypeAlias;
  declare function typeAnnotation(typeAnnotation: any): BabelNodeTypeAnnotation;
  declare function typeCastExpression(expression: any, typeAnnotation: any): BabelNodeTypeCastExpression;
  declare function typeParameter(bound: any): BabelNodeTypeParameter;
  declare function typeParameterDeclaration(params: any): BabelNodeTypeParameterDeclaration;
  declare function typeParameterInstantiation(params: any): BabelNodeTypeParameterInstantiation;
  declare function typeofTypeAnnotation(argument: any): BabelNodeTypeofTypeAnnotation;
  declare function unaryExpression(operator: BabelUnaryOperator, argument: BabelNodeExpression, prefix?: boolean): BabelNodeUnaryExpression;
  declare function unionTypeAnnotation(types: any): BabelNodeUnionTypeAnnotation;
  declare function updateExpression(operator: BabelUpdateOperator, argument: BabelNodeExpression, prefix?: boolean): BabelNodeUpdateExpression;
  declare function variableDeclaration(kind: BabelVariableKind, declarations: Array<BabelNodeVariableDeclarator>): BabelNodeVariableDeclaration;
  declare function variableDeclarator(id: BabelNodeLVal, init?: ?BabelNodeExpression): BabelNodeVariableDeclarator;
  declare function voidTypeAnnotation(): BabelNodeVoidTypeAnnotation;
  declare function whileStatement(test: BabelNodeExpression, body: BabelNodeStatement): BabelNodeWhileStatement;
  declare function withStatement(object: BabelNodeExpression, body: BabelNodeStatement): BabelNodeWithStatement;
  declare function yieldExpression(argument?: ?BabelNodeExpression, delegate?: boolean): BabelNodeYieldExpression;

  declare function isArrayExpression(node: Object, opts?: Object): boolean;
  declare function isAssignmentExpression(node: Object, opts?: Object): boolean;
  declare function isBinaryExpression(node: Object, opts?: Object): boolean;
  declare function isDirective(node: Object, opts?: Object): boolean;
  declare function isDirectiveLiteral(node: Object, opts?: Object): boolean;
  declare function isBlockStatement(node: Object, opts?: Object): boolean;
  declare function isBreakStatement(node: Object, opts?: Object): boolean;
  declare function isCallExpression(node: Object, opts?: Object): boolean;
  declare function isCatchClause(node: Object, opts?: Object): boolean;
  declare function isConditionalExpression(node: Object, opts?: Object): boolean;
  declare function isContinueStatement(node: Object, opts?: Object): boolean;
  declare function isDebuggerStatement(node: Object, opts?: Object): boolean;
  declare function isDoWhileStatement(node: Object, opts?: Object): boolean;
  declare function isEmptyStatement(node: Object, opts?: Object): boolean;
  declare function isExpressionStatement(node: Object, opts?: Object): boolean;
  declare function isFile(node: Object, opts?: Object): boolean;
  declare function isForInStatement(node: Object, opts?: Object): boolean;
  declare function isForStatement(node: Object, opts?: Object): boolean;
  declare function isFunctionDeclaration(node: Object, opts?: Object): boolean;
  declare function isFunctionExpression(node: Object, opts?: Object): boolean;
  declare function isIdentifier(node: Object, opts?: Object): boolean;
  declare function isIfStatement(node: Object, opts?: Object): boolean;
  declare function isLabeledStatement(node: Object, opts?: Object): boolean;
  declare function isStringLiteral(node: Object, opts?: Object): boolean;
  declare function isNumericLiteral(node: Object, opts?: Object): boolean;
  declare function isNullLiteral(node: Object, opts?: Object): boolean;
  declare function isBooleanLiteral(node: Object, opts?: Object): boolean;
  declare function isRegExpLiteral(node: Object, opts?: Object): boolean;
  declare function isLogicalExpression(node: Object, opts?: Object): boolean;
  declare function isMemberExpression(node: Object, opts?: Object): boolean;
  declare function isNewExpression(node: Object, opts?: Object): boolean;
  declare function isProgram(node: Object, opts?: Object): boolean;
  declare function isObjectExpression(node: Object, opts?: Object): boolean;
  declare function isObjectMethod(node: Object, opts?: Object): boolean;
  declare function isObjectProperty(node: Object, opts?: Object): boolean;
  declare function isRestElement(node: Object, opts?: Object): boolean;
  declare function isReturnStatement(node: Object, opts?: Object): boolean;
  declare function isSequenceExpression(node: Object, opts?: Object): boolean;
  declare function isSwitchCase(node: Object, opts?: Object): boolean;
  declare function isSwitchStatement(node: Object, opts?: Object): boolean;
  declare function isThisExpression(node: Object, opts?: Object): boolean;
  declare function isThrowStatement(node: Object, opts?: Object): boolean;
  declare function isTryStatement(node: Object, opts?: Object): boolean;
  declare function isUnaryExpression(node: Object, opts?: Object): boolean;
  declare function isUpdateExpression(node: Object, opts?: Object): boolean;
  declare function isVariableDeclaration(node: Object, opts?: Object): boolean;
  declare function isVariableDeclarator(node: Object, opts?: Object): boolean;
  declare function isWhileStatement(node: Object, opts?: Object): boolean;
  declare function isWithStatement(node: Object, opts?: Object): boolean;
  declare function isAssignmentPattern(node: Object, opts?: Object): boolean;
  declare function isArrayPattern(node: Object, opts?: Object): boolean;
  declare function isArrowFunctionExpression(node: Object, opts?: Object): boolean;
  declare function isClassBody(node: Object, opts?: Object): boolean;
  declare function isClassDeclaration(node: Object, opts?: Object): boolean;
  declare function isClassExpression(node: Object, opts?: Object): boolean;
  declare function isExportAllDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportDefaultDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportNamedDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportSpecifier(node: Object, opts?: Object): boolean;
  declare function isForOfStatement(node: Object, opts?: Object): boolean;
  declare function isImportDeclaration(node: Object, opts?: Object): boolean;
  declare function isImportDefaultSpecifier(node: Object, opts?: Object): boolean;
  declare function isImportNamespaceSpecifier(node: Object, opts?: Object): boolean;
  declare function isImportSpecifier(node: Object, opts?: Object): boolean;
  declare function isMetaProperty(node: Object, opts?: Object): boolean;
  declare function isClassMethod(node: Object, opts?: Object): boolean;
  declare function isObjectPattern(node: Object, opts?: Object): boolean;
  declare function isSpreadElement(node: Object, opts?: Object): boolean;
  declare function isSuper(node: Object, opts?: Object): boolean;
  declare function isTaggedTemplateExpression(node: Object, opts?: Object): boolean;
  declare function isTemplateElement(node: Object, opts?: Object): boolean;
  declare function isTemplateLiteral(node: Object, opts?: Object): boolean;
  declare function isYieldExpression(node: Object, opts?: Object): boolean;
  declare function isAnyTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isArrayTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isBooleanTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isBooleanLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNullLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isClassImplements(node: Object, opts?: Object): boolean;
  declare function isClassProperty(node: Object, opts?: Object): boolean;
  declare function isDeclareClass(node: Object, opts?: Object): boolean;
  declare function isDeclareFunction(node: Object, opts?: Object): boolean;
  declare function isDeclareInterface(node: Object, opts?: Object): boolean;
  declare function isDeclareModule(node: Object, opts?: Object): boolean;
  declare function isDeclareModuleExports(node: Object, opts?: Object): boolean;
  declare function isDeclareTypeAlias(node: Object, opts?: Object): boolean;
  declare function isDeclareVariable(node: Object, opts?: Object): boolean;
  declare function isExistentialTypeParam(node: Object, opts?: Object): boolean;
  declare function isFunctionTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isFunctionTypeParam(node: Object, opts?: Object): boolean;
  declare function isGenericTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isInterfaceExtends(node: Object, opts?: Object): boolean;
  declare function isInterfaceDeclaration(node: Object, opts?: Object): boolean;
  declare function isIntersectionTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isMixedTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isEmptyTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNullableTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNumericLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNumberTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isStringLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isStringTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isThisTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTupleTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTypeofTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTypeAlias(node: Object, opts?: Object): boolean;
  declare function isTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTypeCastExpression(node: Object, opts?: Object): boolean;
  declare function isTypeParameter(node: Object, opts?: Object): boolean;
  declare function isTypeParameterDeclaration(node: Object, opts?: Object): boolean;
  declare function isTypeParameterInstantiation(node: Object, opts?: Object): boolean;
  declare function isObjectTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isObjectTypeCallProperty(node: Object, opts?: Object): boolean;
  declare function isObjectTypeIndexer(node: Object, opts?: Object): boolean;
  declare function isObjectTypeProperty(node: Object, opts?: Object): boolean;
  declare function isQualifiedTypeIdentifier(node: Object, opts?: Object): boolean;
  declare function isUnionTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isVoidTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isJSXAttribute(node: Object, opts?: Object): boolean;
  declare function isJSXClosingElement(node: Object, opts?: Object): boolean;
  declare function isJSXElement(node: Object, opts?: Object): boolean;
  declare function isJSXEmptyExpression(node: Object, opts?: Object): boolean;
  declare function isJSXExpressionContainer(node: Object, opts?: Object): boolean;
  declare function isJSXIdentifier(node: Object, opts?: Object): boolean;
  declare function isJSXMemberExpression(node: Object, opts?: Object): boolean;
  declare function isJSXNamespacedName(node: Object, opts?: Object): boolean;
  declare function isJSXOpeningElement(node: Object, opts?: Object): boolean;
  declare function isJSXSpreadAttribute(node: Object, opts?: Object): boolean;
  declare function isJSXText(node: Object, opts?: Object): boolean;
  declare function isNoop(node: Object, opts?: Object): boolean;
  declare function isParenthesizedExpression(node: Object, opts?: Object): boolean;
  declare function isAwaitExpression(node: Object, opts?: Object): boolean;
  declare function isForAwaitStatement(node: Object, opts?: Object): boolean;
  declare function isBindExpression(node: Object, opts?: Object): boolean;
  declare function isDecorator(node: Object, opts?: Object): boolean;
  declare function isDoExpression(node: Object, opts?: Object): boolean;
  declare function isExportDefaultSpecifier(node: Object, opts?: Object): boolean;
  declare function isExportNamespaceSpecifier(node: Object, opts?: Object): boolean;
  declare function isRestProperty(node: Object, opts?: Object): boolean;
  declare function isExpression(node: Object, opts?: Object): boolean;
  declare function isBinary(node: Object, opts?: Object): boolean;
  declare function isScopable(node: Object, opts?: Object): boolean;
  declare function isBlockParent(node: Object, opts?: Object): boolean;
  declare function isBlock(node: Object, opts?: Object): boolean;
  declare function isStatement(node: Object, opts?: Object): boolean;
  declare function isTerminatorless(node: Object, opts?: Object): boolean;
  declare function isCompletionStatement(node: Object, opts?: Object): boolean;
  declare function isConditional(node: Object, opts?: Object): boolean;
  declare function isLoop(node: Object, opts?: Object): boolean;
  declare function isWhile(node: Object, opts?: Object): boolean;
  declare function isExpressionWrapper(node: Object, opts?: Object): boolean;
  declare function isFor(node: Object, opts?: Object): boolean;
  declare function isForXStatement(node: Object, opts?: Object): boolean;
  declare function isFunction(node: Object, opts?: Object): boolean;
  declare function isFunctionParent(node: Object, opts?: Object): boolean;
  declare function isPureish(node: Object, opts?: Object): boolean;
  declare function isDeclaration(node: Object, opts?: Object): boolean;
  declare function isLVal(node: Object, opts?: Object): boolean;
  declare function isLiteral(node: Object, opts?: Object): boolean;
  declare function isImmutable(node: Object, opts?: Object): boolean;
  declare function isUserWhitespacable(node: Object, opts?: Object): boolean;
  declare function isMethod(node: Object, opts?: Object): boolean;
  declare function isObjectMember(node: Object, opts?: Object): boolean;
  declare function isProperty(node: Object, opts?: Object): boolean;
  declare function isUnaryLike(node: Object, opts?: Object): boolean;
  declare function isPattern(node: Object, opts?: Object): boolean;
  declare function isClass(node: Object, opts?: Object): boolean;
  declare function isModuleDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportDeclaration(node: Object, opts?: Object): boolean;
  declare function isModuleSpecifier(node: Object, opts?: Object): boolean;
  declare function isFlow(node: Object, opts?: Object): boolean;
  declare function isFlowBaseAnnotation(node: Object, opts?: Object): boolean;
  declare function isFlowDeclaration(node: Object, opts?: Object): boolean;
  declare function isJSX(node: Object, opts?: Object): boolean;
  declare function isNumberLiteral(node: Object, opts?: Object): boolean;
  declare function isRegexLiteral(node: Object, opts?: Object): boolean;

  declare function isValidIdentifier(name: string): boolean;
  declare function getBindingIdentifiers(
    node: Object | Array<Object>,
    duplicates?: boolean,
    outerOnly?: boolean
  ): Object;
  declare function getOuterBindingIdentifiers(
    node: Object | Array<Object>,
    duplicates?: boolean,
  ): Object;
  declare var VISITOR_KEYS: {[id:string]: Function};
  declare function valueToNode(value: any): BabelNodeExpression;
  declare function cloneDeep(node: BabelNode): BabelNode;
}

declare module "babel-types" {
  declare type BabelObjectMethodKind = "get" | "set" | "method";
  declare type BabelLogicalOperator = "||" | "&&";
  declare type BabelAssignmentOperator = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";
  declare type BabelBinaryOperator = "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=";
  declare type BabelUnaryOperator = "void" | "delete" | "!" | "+" | "-" | "++" | "--" | "~" | "typeof";
  declare type BabelUpdateOperator = "++" | "--";
  declare type BabelVariableKind = "var" | "let" | "const";

  declare class BabelNodeComment {
    +type: "BlockComment" | "LineComment";
    value: string;
    start: number;
    end: number;
    loc: BabelNodeSourceLocation;
  }

  declare class BabelNodeBlockComment extends BabelNodeComment {
    type: "BlockComment";
  }

  declare class BabelNodeLineComment extends BabelNodeComment {
    type: "LineComment";
  }

  declare class BabelNodePosition {
    line: number;
    column: number;
  }

  declare class BabelNodeSourceLocation {
    source: string | null;
    start: BabelNodePosition;
    end: BabelNodePosition;
  }

  declare class BabelNode {
    +type: "ArrayExpression" |
      "AssignmentExpression" |
      "BinaryExpression" |
      "Directive" |
      "DirectiveLiteral" |
      "BlockStatement" |
      "BreakStatement" |
      "CallExpression" |
      "CatchClause" |
      "ConditionalExpression" |
      "ContinueStatement" |
      "DebuggerStatement" |
      "DoWhileStatement" |
      "EmptyStatement" |
      "ExpressionStatement" |
      "File" |
      "ForInStatement" |
      "ForStatement" |
      "FunctionDeclaration" |
      "FunctionExpression" |
      "Identifier" |
      "IfStatement" |
      "LabeledStatement" |
      "StringLiteral" |
      "NumericLiteral" |
      "NullLiteral" |
      "BooleanLiteral" |
      "RegExpLiteral" |
      "LogicalExpression" |
      "MemberExpression" |
      "NewExpression" |
      "Program" |
      "ObjectExpression" |
      "ObjectMethod" |
      "ObjectProperty" |
      "RestElement" |
      "ReturnStatement" |
      "SequenceExpression" |
      "SwitchCase" |
      "SwitchStatement" |
      "ThisExpression" |
      "ThrowStatement" |
      "TryStatement" |
      "UnaryExpression" |
      "UpdateExpression" |
      "VariableDeclaration" |
      "VariableDeclarator" |
      "WhileStatement" |
      "WithStatement" |
      "AssignmentPattern" |
      "ArrayPattern" |
      "ArrowFunctionExpression" |
      "ClassBody" |
      "ClassDeclaration" |
      "ClassExpression" |
      "ExportAllDeclaration" |
      "ExportDefaultDeclaration" |
      "ExportNamedDeclaration" |
      "ExportSpecifier" |
      "ForOfStatement" |
      "ImportDeclaration" |
      "ImportDefaultSpecifier" |
      "ImportNamespaceSpecifier" |
      "ImportSpecifier" |
      "MetaProperty" |
      "ClassMethod" |
      "ObjectPattern" |
      "SpreadElement" |
      "Super" |
      "TaggedTemplateExpression" |
      "TemplateElement" |
      "TemplateLiteral" |
      "YieldExpression" |
      "AnyTypeAnnotation" |
      "ArrayTypeAnnotation" |
      "BooleanTypeAnnotation" |
      "BooleanLiteralTypeAnnotation" |
      "NullLiteralTypeAnnotation" |
      "ClassImplements" |
      "ClassProperty" |
      "DeclareClass" |
      "DeclareFunction" |
      "DeclareInterface" |
      "DeclareModule" |
      "DeclareModuleExports" |
      "DeclareTypeAlias" |
      "DeclareVariable" |
      "ExistentialTypeParam" |
      "FunctionTypeAnnotation" |
      "FunctionTypeParam" |
      "GenericTypeAnnotation" |
      "InterfaceExtends" |
      "InterfaceDeclaration" |
      "IntersectionTypeAnnotation" |
      "MixedTypeAnnotation" |
      "EmptyTypeAnnotation" |
      "NullableTypeAnnotation" |
      "NumericLiteralTypeAnnotation" |
      "NumberTypeAnnotation" |
      "StringLiteralTypeAnnotation" |
      "StringTypeAnnotation" |
      "ThisTypeAnnotation" |
      "TupleTypeAnnotation" |
      "TypeofTypeAnnotation" |
      "TypeAlias" |
      "TypeAnnotation" |
      "TypeCastExpression" |
      "TypeParameter" |
      "TypeParameterDeclaration" |
      "TypeParameterInstantiation" |
      "ObjectTypeAnnotation" |
      "ObjectTypeCallProperty" |
      "ObjectTypeIndexer" |
      "ObjectTypeProperty" |
      "QualifiedTypeIdentifier" |
      "UnionTypeAnnotation" |
      "VoidTypeAnnotation" |
      "JSXAttribute" |
      "JSXClosingElement" |
      "JSXElement" |
      "JSXEmptyExpression" |
      "JSXExpressionContainer" |
      "JSXIdentifier" |
      "JSXMemberExpression" |
      "JSXNamespacedName" |
      "JSXOpeningElement" |
      "JSXSpreadAttribute" |
      "JSXText" |
      "Noop" |
      "ParenthesizedExpression" |
      "AwaitExpression" |
      "ForAwaitStatement" |
      "BindExpression" |
      "Decorator" |
      "DoExpression" |
      "ExportDefaultSpecifier" |
      "ExportNamespaceSpecifier" |
      "RestProperty" ;
    leadingComments: ?Array<BabelNodeComment>;
    innerComments: ?Array<BabelNodeComment>;
    trailingComments: ?Array<BabelNodeComment>;
    start: ?number;
    end: ?number;
    loc: ?BabelNodeSourceLocation;
  }

  declare class BabelNodeArrayExpression extends BabelNode {
    type: "ArrayExpression";
    elements: Array<void | BabelNodeExpression | BabelNodeSpreadElement>;
  }

  declare class BabelNodeAssignmentExpression extends BabelNode {
    type: "AssignmentExpression";
    operator: BabelAssignmentOperator;
    left: BabelNodeLVal;
    right: BabelNodeExpression;
  }

  declare class BabelNodeBinaryExpression extends BabelNode {
    type: "BinaryExpression";
    operator: BabelBinaryOperator;
    left: BabelNodeExpression;
    right: BabelNodeExpression;
  }

  declare class BabelNodeDirective extends BabelNode {
    type: "Directive";
    value: BabelNodeDirectiveLiteral;
  }

  declare class BabelNodeDirectiveLiteral extends BabelNode {
    type: "DirectiveLiteral";
    value: string;
  }

  declare class BabelNodeBlockStatement extends BabelNode {
    type: "BlockStatement";
    directives?: Array<BabelNodeDirective>;
    body: Array<BabelNodeStatement>;
  }

  declare class BabelNodeBreakStatement extends BabelNode {
    type: "BreakStatement";
    label?: ?BabelNodeIdentifier;
  }

  declare class BabelNodeCallExpression extends BabelNode {
    type: "CallExpression";
    callee: BabelNodeExpression;
    arguments: Array<BabelNodeExpression | BabelNodeSpreadElement>;
  }

  declare class BabelNodeCatchClause extends BabelNode {
    type: "CatchClause";
    param: BabelNodePattern;
    body: BabelNodeBlockStatement;
  }

  declare class BabelNodeConditionalExpression extends BabelNode {
    type: "ConditionalExpression";
    test: BabelNodeExpression;
    consequent: BabelNodeExpression;
    alternate: BabelNodeExpression;
  }

  declare class BabelNodeContinueStatement extends BabelNode {
    type: "ContinueStatement";
    label?: ?BabelNodeIdentifier;
  }

  declare class BabelNodeDebuggerStatement extends BabelNode {
    type: "DebuggerStatement";
  }

  declare class BabelNodeDoWhileStatement extends BabelNode {
    type: "DoWhileStatement";
    test: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeEmptyStatement extends BabelNode {
    type: "EmptyStatement";
  }

  declare class BabelNodeExpressionStatement extends BabelNode {
    type: "ExpressionStatement";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeFile extends BabelNode {
    type: "File";
    program: BabelNodeProgram;
    comments: any;
    tokens: any;
  }

  declare class BabelNodeForInStatement extends BabelNode {
    type: "ForInStatement";
    left: BabelNodeVariableDeclaration | BabelNodeLVal;
    right: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeForStatement extends BabelNode {
    type: "ForStatement";
    init?: ?BabelNodeVariableDeclaration | BabelNodeExpression;
    test?: ?BabelNodeExpression;
    update?: ?BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeFunctionDeclaration extends BabelNode {
    type: "FunctionDeclaration";
    id: BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator: boolean;
    async: boolean;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeFunctionExpression extends BabelNode {
    type: "FunctionExpression";
    id?: ?BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator?: boolean;
    async?: boolean;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeIdentifier extends BabelNode {
    type: "Identifier";
    name: string;
    decorators?: any;
    typeAnnotation?: any;
  }

  declare class BabelNodeIfStatement extends BabelNode {
    type: "IfStatement";
    test: BabelNodeExpression;
    consequent: BabelNodeStatement;
    alternate?: ?BabelNodeStatement;
  }

  declare class BabelNodeLabeledStatement extends BabelNode {
    type: "LabeledStatement";
    label: BabelNodeIdentifier;
    body: BabelNodeStatement;
  }

  declare class BabelNodeStringLiteral extends BabelNode {
    type: "StringLiteral";
    value: string;
  }

  declare class BabelNodeNumericLiteral extends BabelNode {
    type: "NumericLiteral";
    value: number;
  }

  declare class BabelNodeNullLiteral extends BabelNode {
    type: "NullLiteral";
  }

  declare class BabelNodeBooleanLiteral extends BabelNode {
    type: "BooleanLiteral";
    value: boolean;
  }

  declare class BabelNodeRegExpLiteral extends BabelNode {
    type: "RegExpLiteral";
    pattern: string;
    flags?: string;
  }

  declare class BabelNodeLogicalExpression extends BabelNode {
    type: "LogicalExpression";
    operator: BabelLogicalOperator;
    left: BabelNodeExpression;
    right: BabelNodeExpression;
  }

  declare class BabelNodeMemberExpression extends BabelNode {
    type: "MemberExpression";
    object: BabelNodeExpression;
    property: any;
    computed?: boolean;
  }

  declare class BabelNodeNewExpression extends BabelNode {
    type: "NewExpression";
    callee: BabelNodeExpression;
    arguments: Array<BabelNode>;
  }

  declare class BabelNodeProgram extends BabelNode {
    type: "Program";
    sourceType: "script" | "module";
    directives?: Array<BabelNodeDirective>;
    body: Array<BabelNodeStatement | BabelNodeModuleDeclaration>;
  }

  declare class BabelNodeObjectExpression extends BabelNode {
    type: "ObjectExpression";
    properties: Array<BabelNodeObjectProperty>;
  }

  declare class BabelNodeObjectMethod extends BabelNode {
    type: "ObjectMethod";
    kind: BabelObjectMethodKind;
    computed: boolean;
    key: BabelNodeExpression;
    decorators: Array<BabelNodeDecorator>;
    value: BabelNodeExpression;
    id?: ?BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator?: boolean;
    async: boolean;
  }

  declare class BabelNodeObjectProperty extends BabelNode {
    type: "ObjectProperty";
    computed: boolean;
    key: BabelNodeExpression;
    decorators: Array<BabelNodeDecorator>;
    value: BabelNodeExpression;
  }

  declare class BabelNodeRestElement extends BabelNode {
    type: "RestElement";
    argument: BabelNodePattern;
    decorators?: any;
    typeAnnotation: any;
  }

  declare class BabelNodeReturnStatement extends BabelNode {
    type: "ReturnStatement";
    argument?: ?BabelNodeExpression;
  }

  declare class BabelNodeSequenceExpression extends BabelNode {
    type: "SequenceExpression";
    expressions: Array<BabelNodeExpression>;
  }

  declare class BabelNodeSwitchCase extends BabelNode {
    type: "SwitchCase";
    test?: ?BabelNodeExpression;
    consequent: Array<BabelNodeStatement>;
  }

  declare class BabelNodeSwitchStatement extends BabelNode {
    type: "SwitchStatement";
    discriminant: BabelNodeExpression;
    cases: Array<BabelNodeSwitchCase>;
  }

  declare class BabelNodeThisExpression extends BabelNode {
    type: "ThisExpression";
  }

  declare class BabelNodeThrowStatement extends BabelNode {
    type: "ThrowStatement";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeTryStatement extends BabelNode {
    type: "TryStatement";
    body?: ?BabelNodeBlockStatement;
    handler?: ?BabelNodeCatchClause;
    finalizer?: ?BabelNodeBlockStatement;
    block: BabelNodeBlockStatement;
  }

  declare class BabelNodeUnaryExpression extends BabelNode {
    type: "UnaryExpression";
    prefix?: boolean;
    argument: BabelNodeExpression;
    operator: BabelUnaryOperator;
  }

  declare class BabelNodeUpdateExpression extends BabelNode {
    type: "UpdateExpression";
    prefix?: boolean;
    argument: BabelNodeExpression;
    operator: BabelUpdateOperator;
  }

  declare class BabelNodeVariableDeclaration extends BabelNode {
    type: "VariableDeclaration";
    kind: BabelVariableKind;
    declarations: Array<BabelNodeVariableDeclarator>;
  }

  declare class BabelNodeVariableDeclarator extends BabelNode {
    type: "VariableDeclarator";
    id: BabelNodeLVal;
    init?: ?BabelNodeExpression;
  }

  declare class BabelNodeWhileStatement extends BabelNode {
    type: "WhileStatement";
    test: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeWithStatement extends BabelNode {
    type: "WithStatement";
    object: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeAssignmentPattern extends BabelNode {
    type: "AssignmentPattern";
    left: BabelNodeIdentifier;
    right: BabelNodeExpression;
    decorators?: any;
  }

  declare class BabelNodeArrayPattern extends BabelNode {
    type: "ArrayPattern";
    elements: any;
    decorators?: any;
    typeAnnotation: any;
  }

  declare class BabelNodeArrowFunctionExpression extends BabelNode {
    type: "ArrowFunctionExpression";
    body: BabelNodeBlockStatement | BabelNodeExpression;
    expression: boolean;
    id?: ?BabelNodeIdentifier;
    params: Array<BabelNodeLVal>;
    generator?: boolean;
    async: boolean;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeClassBody extends BabelNode {
    type: "ClassBody";
    body: Array<BabelNodeClassMethod | BabelNodeClassProperty>;
  }

  declare class BabelNodeClassDeclaration extends BabelNode {
    type: "ClassDeclaration";
    id: BabelNodeIdentifier;
    body: BabelNodeClassBody;
    superClass?: ?BabelNodeExpression;
    decorators: Array<BabelNodeDecorator>;
    mixins?: any;
    typeParameters?: any;
    superTypeParameters?: any;
  }

  declare class BabelNodeClassExpression extends BabelNode {
    type: "ClassExpression";
    id?: ?BabelNodeIdentifier;
    body: BabelNodeClassBody;
    superClass?: ?BabelNodeExpression;
    decorators: any;
    mixins?: any;
    typeParameters?: any;
    superTypeParameters?: any;
  }

  declare class BabelNodeExportAllDeclaration extends BabelNode {
    type: "ExportAllDeclaration";
    source: BabelNodeStringLiteral;
  }

  declare class BabelNodeExportDefaultDeclaration extends BabelNode {
    type: "ExportDefaultDeclaration";
    declaration: BabelNodeFunctionDeclaration | BabelNodeClassDeclaration | BabelNodeExpression;
  }

  declare class BabelNodeExportNamedDeclaration extends BabelNode {
    type: "ExportNamedDeclaration";
    declaration?: ?BabelNodeDeclaration;
    specifiers: Array<BabelNodeExportSpecifier>;
    source?: ?BabelNodeStringLiteral;
  }

  declare class BabelNodeExportSpecifier extends BabelNode {
    type: "ExportSpecifier";
    local: BabelNodeIdentifier;
    exported: BabelNodeIdentifier;
  }

  declare class BabelNodeForOfStatement extends BabelNode {
    type: "ForOfStatement";
    left: BabelNodeVariableDeclaration | BabelNodeLVal;
    right: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeImportDeclaration extends BabelNode {
    type: "ImportDeclaration";
    specifiers: [BabelNodeImportSpecifier | BabelNodeImportDefaultSpecifier | BabelNodeImportNamespaceSpecifier];
    source: BabelNodeStringLiteral;
  }

  declare class BabelNodeImportDefaultSpecifier extends BabelNode {
    type: "ImportDefaultSpecifier";
    local: BabelNodeIdentifier;
  }

  declare class BabelNodeImportNamespaceSpecifier extends BabelNode {
    type: "ImportNamespaceSpecifier";
    local: BabelNodeIdentifier;
  }

  declare class BabelNodeImportSpecifier extends BabelNode {
    type: "ImportSpecifier";
    local: BabelNodeIdentifier;
    imported: BabelNodeIdentifier;
  }

  declare class BabelNodeMetaProperty extends BabelNode {
    type: "MetaProperty";
    meta: BabelNodeIdentifier;
    property: BabelNodeIdentifier;
  }

  declare class BabelNodeClassMethod extends BabelNode {
    type: "ClassMethod";
    kind?: any;
    computed?: boolean;
    key: any;
    params: Array<BabelNodeLVal>;
    body: BabelNodeBlockStatement;
    generator?: boolean;
    async?: boolean;
    decorators: Array<BabelNodeDecorator>;
    returnType?: any;
    typeParameters?: any;
  }

  declare class BabelNodeObjectPattern extends BabelNode {
    type: "ObjectPattern";
    properties: any;
    decorators?: any;
    typeAnnotation: any;
  }

  declare class BabelNodeSpreadElement extends BabelNode {
    type: "SpreadElement";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeSuper extends BabelNode {
    type: "Super";
  }

  declare class BabelNodeTaggedTemplateExpression extends BabelNode {
    type: "TaggedTemplateExpression";
    tag: BabelNodeExpression;
    quasi: BabelNodeTemplateLiteral;
  }

  declare class BabelNodeTemplateElement extends BabelNode {
    type: "TemplateElement";
    value: { cooked: string, raw: string };
    tail: boolean;
  }

  declare class BabelNodeTemplateLiteral extends BabelNode {
    type: "TemplateLiteral";
    quasis: Array<BabelNodeTemplateElement>;
    expressions: Array<BabelNodeExpression>;
  }

  declare class BabelNodeYieldExpression extends BabelNode {
    type: "YieldExpression";
    delegate: boolean;
    argument?: ?BabelNodeExpression;
  }

  declare class BabelNodeAnyTypeAnnotation extends BabelNode {
    type: "AnyTypeAnnotation";
  }

  declare class BabelNodeArrayTypeAnnotation extends BabelNode {
    type: "ArrayTypeAnnotation";
    elementType: any;
  }

  declare class BabelNodeBooleanTypeAnnotation extends BabelNode {
    type: "BooleanTypeAnnotation";
  }

  declare class BabelNodeBooleanLiteralTypeAnnotation extends BabelNode {
    type: "BooleanLiteralTypeAnnotation";
  }

  declare class BabelNodeNullLiteralTypeAnnotation extends BabelNode {
    type: "NullLiteralTypeAnnotation";
  }

  declare class BabelNodeClassImplements extends BabelNode {
    type: "ClassImplements";
    id: any;
    typeParameters: any;
  }

  declare class BabelNodeClassProperty extends BabelNode {
    type: "ClassProperty";
    computed: boolean;
    key: BabelNodeIdentifier;
    value: BabelNodeExpression;
    typeAnnotation: any;
    decorators: Array<BabelNodeDecorator>;
  }

  declare class BabelNodeDeclareClass extends BabelNode {
    type: "DeclareClass";
    id: any;
    typeParameters: any;
    body: any;
  }

  declare class BabelNodeDeclareFunction extends BabelNode {
    type: "DeclareFunction";
    id: any;
  }

  declare class BabelNodeDeclareInterface extends BabelNode {
    type: "DeclareInterface";
    id: any;
    typeParameters: any;
    body: any;
  }

  declare class BabelNodeDeclareModule extends BabelNode {
    type: "DeclareModule";
    id: any;
    body: any;
  }

  declare class BabelNodeDeclareModuleExports extends BabelNode {
    type: "DeclareModuleExports";
    typeAnnotation: any;
  }

  declare class BabelNodeDeclareTypeAlias extends BabelNode {
    type: "DeclareTypeAlias";
    id: any;
    typeParameters: any;
    right: any;
  }

  declare class BabelNodeDeclareVariable extends BabelNode {
    type: "DeclareVariable";
    id: any;
  }

  declare class BabelNodeExistentialTypeParam extends BabelNode {
    type: "ExistentialTypeParam";
  }

  declare class BabelNodeFunctionTypeAnnotation extends BabelNode {
    type: "FunctionTypeAnnotation";
    typeParameters: any;
    params: any;
    rest: any;
    returnType: any;
  }

  declare class BabelNodeFunctionTypeParam extends BabelNode {
    type: "FunctionTypeParam";
    name: any;
    typeAnnotation: any;
  }

  declare class BabelNodeGenericTypeAnnotation extends BabelNode {
    type: "GenericTypeAnnotation";
    id: any;
    typeParameters: any;
  }

  declare class BabelNodeInterfaceExtends extends BabelNode {
    type: "InterfaceExtends";
    id: any;
    typeParameters: any;
  }

  declare class BabelNodeInterfaceDeclaration extends BabelNode {
    type: "InterfaceDeclaration";
    id: any;
    typeParameters: any;
    body: any;
  }

  declare class BabelNodeIntersectionTypeAnnotation extends BabelNode {
    type: "IntersectionTypeAnnotation";
    types: any;
  }

  declare class BabelNodeMixedTypeAnnotation extends BabelNode {
    type: "MixedTypeAnnotation";
  }

  declare class BabelNodeEmptyTypeAnnotation extends BabelNode {
    type: "EmptyTypeAnnotation";
  }

  declare class BabelNodeNullableTypeAnnotation extends BabelNode {
    type: "NullableTypeAnnotation";
    typeAnnotation: any;
  }

  declare class BabelNodeNumericLiteralTypeAnnotation extends BabelNode {
    type: "NumericLiteralTypeAnnotation";
  }

  declare class BabelNodeNumberTypeAnnotation extends BabelNode {
    type: "NumberTypeAnnotation";
  }

  declare class BabelNodeStringLiteralTypeAnnotation extends BabelNode {
    type: "StringLiteralTypeAnnotation";
  }

  declare class BabelNodeStringTypeAnnotation extends BabelNode {
    type: "StringTypeAnnotation";
  }

  declare class BabelNodeThisTypeAnnotation extends BabelNode {
    type: "ThisTypeAnnotation";
  }

  declare class BabelNodeTupleTypeAnnotation extends BabelNode {
    type: "TupleTypeAnnotation";
    types: any;
  }

  declare class BabelNodeTypeofTypeAnnotation extends BabelNode {
    type: "TypeofTypeAnnotation";
    argument: any;
  }

  declare class BabelNodeTypeAlias extends BabelNode {
    type: "TypeAlias";
    id: any;
    typeParameters: any;
    right: any;
  }

  declare class BabelNodeTypeAnnotation extends BabelNode {
    type: "TypeAnnotation";
    typeAnnotation: any;
  }

  declare class BabelNodeTypeCastExpression extends BabelNode {
    type: "TypeCastExpression";
    expression: any;
    typeAnnotation: any;
  }

  declare class BabelNodeTypeParameter extends BabelNode {
    type: "TypeParameter";
    bound: any;
  }

  declare class BabelNodeTypeParameterDeclaration extends BabelNode {
    type: "TypeParameterDeclaration";
    params: any;
  }

  declare class BabelNodeTypeParameterInstantiation extends BabelNode {
    type: "TypeParameterInstantiation";
    params: any;
  }

  declare class BabelNodeObjectTypeAnnotation extends BabelNode {
    type: "ObjectTypeAnnotation";
    properties: any;
    indexers: any;
    callProperties: any;
  }

  declare class BabelNodeObjectTypeCallProperty extends BabelNode {
    type: "ObjectTypeCallProperty";
    value: any;
  }

  declare class BabelNodeObjectTypeIndexer extends BabelNode {
    type: "ObjectTypeIndexer";
    id: any;
    key: any;
    value: any;
  }

  declare class BabelNodeObjectTypeProperty extends BabelNode {
    type: "ObjectTypeProperty";
    key: any;
    value: any;
  }

  declare class BabelNodeQualifiedTypeIdentifier extends BabelNode {
    type: "QualifiedTypeIdentifier";
    id: any;
    qualification: any;
  }

  declare class BabelNodeUnionTypeAnnotation extends BabelNode {
    type: "UnionTypeAnnotation";
    types: any;
  }

  declare class BabelNodeVoidTypeAnnotation extends BabelNode {
    type: "VoidTypeAnnotation";
  }

  declare class BabelNodeJSXAttribute extends BabelNode {
    type: "JSXAttribute";
    name: BabelNodeJSXIdentifier | BabelNodeJSXNamespacedName;
    value?: ?BabelNodeJSXElement | BabelNodeStringLiteral | BabelNodeJSXExpressionContainer;
  }

  declare class BabelNodeJSXClosingElement extends BabelNode {
    type: "JSXClosingElement";
    name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression;
  }

  declare class BabelNodeJSXElement extends BabelNode {
    type: "JSXElement";
    openingElement: BabelNodeJSXOpeningElement;
    closingElement?: ?BabelNodeJSXClosingElement;
    children: any;
    selfClosing: any;
  }

  declare class BabelNodeJSXEmptyExpression extends BabelNode {
    type: "JSXEmptyExpression";
  }

  declare class BabelNodeJSXExpressionContainer extends BabelNode {
    type: "JSXExpressionContainer";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeJSXIdentifier extends BabelNode {
    type: "JSXIdentifier";
    name: string;
  }

  declare class BabelNodeJSXMemberExpression extends BabelNode {
    type: "JSXMemberExpression";
    object: BabelNodeJSXMemberExpression | BabelNodeJSXIdentifier;
    property: BabelNodeJSXIdentifier;
  }

  declare class BabelNodeJSXNamespacedName extends BabelNode {
    type: "JSXNamespacedName";
    namespace: BabelNodeJSXIdentifier;
    name: BabelNodeJSXIdentifier;
  }

  declare class BabelNodeJSXOpeningElement extends BabelNode {
    type: "JSXOpeningElement";
    name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression;
    selfClosing?: boolean;
    attributes: any;
  }

  declare class BabelNodeJSXSpreadAttribute extends BabelNode {
    type: "JSXSpreadAttribute";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeJSXText extends BabelNode {
    type: "JSXText";
    value: string;
  }

  declare class BabelNodeNoop extends BabelNode {
    type: "Noop";
  }

  declare class BabelNodeParenthesizedExpression extends BabelNode {
    type: "ParenthesizedExpression";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeAwaitExpression extends BabelNode {
    type: "AwaitExpression";
    argument: BabelNodeExpression;
  }

  declare class BabelNodeForAwaitStatement extends BabelNode {
    type: "ForAwaitStatement";
    left: BabelNodeVariableDeclaration | BabelNodeLVal;
    right: BabelNodeExpression;
    body: BabelNodeStatement;
  }

  declare class BabelNodeBindExpression extends BabelNode {
    type: "BindExpression";
    object: any;
    callee: any;
  }

  declare class BabelNodeDecorator extends BabelNode {
    type: "Decorator";
    expression: BabelNodeExpression;
  }

  declare class BabelNodeDoExpression extends BabelNode {
    type: "DoExpression";
    body: BabelNodeBlockStatement;
  }

  declare class BabelNodeExportDefaultSpecifier extends BabelNode {
    type: "ExportDefaultSpecifier";
    exported: BabelNodeIdentifier;
  }

  declare class BabelNodeExportNamespaceSpecifier extends BabelNode {
    type: "ExportNamespaceSpecifier";
    exported: BabelNodeIdentifier;
  }

  declare class BabelNodeRestProperty extends BabelNode {
    type: "RestProperty";
    argument: BabelNodeLVal;
  }

  declare type BabelNodeExpression = BabelNodeArrayExpression | BabelNodeAssignmentExpression | BabelNodeBinaryExpression | BabelNodeCallExpression | BabelNodeConditionalExpression | BabelNodeFunctionExpression | BabelNodeIdentifier | BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeRegExpLiteral | BabelNodeLogicalExpression | BabelNodeMemberExpression | BabelNodeNewExpression | BabelNodeObjectExpression | BabelNodeSequenceExpression | BabelNodeThisExpression | BabelNodeUnaryExpression | BabelNodeUpdateExpression | BabelNodeArrowFunctionExpression | BabelNodeClassExpression | BabelNodeMetaProperty | BabelNodeSuper | BabelNodeTaggedTemplateExpression | BabelNodeTemplateLiteral | BabelNodeYieldExpression | BabelNodeTypeCastExpression | BabelNodeJSXElement | BabelNodeJSXEmptyExpression | BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression | BabelNodeParenthesizedExpression | BabelNodeAwaitExpression | BabelNodeBindExpression | BabelNodeDoExpression;
  declare type BabelNodeBinary = BabelNodeBinaryExpression | BabelNodeLogicalExpression;
  declare type BabelNodeScopable = BabelNodeBlockStatement | BabelNodeCatchClause | BabelNodeDoWhileStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeProgram | BabelNodeObjectMethod | BabelNodeSwitchStatement | BabelNodeWhileStatement | BabelNodeArrowFunctionExpression | BabelNodeClassDeclaration | BabelNodeClassExpression | BabelNodeForOfStatement | BabelNodeClassMethod | BabelNodeForAwaitStatement;
  declare type BabelNodeBlockParent = BabelNodeBlockStatement | BabelNodeDoWhileStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeProgram | BabelNodeObjectMethod | BabelNodeSwitchStatement | BabelNodeWhileStatement | BabelNodeArrowFunctionExpression | BabelNodeForOfStatement | BabelNodeClassMethod | BabelNodeForAwaitStatement;
  declare type BabelNodeBlock = BabelNodeBlockStatement | BabelNodeProgram;
  declare type BabelNodeStatement = BabelNodeBlockStatement | BabelNodeBreakStatement | BabelNodeContinueStatement | BabelNodeDebuggerStatement | BabelNodeDoWhileStatement | BabelNodeEmptyStatement | BabelNodeExpressionStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeFunctionDeclaration | BabelNodeIfStatement | BabelNodeLabeledStatement | BabelNodeReturnStatement | BabelNodeSwitchStatement | BabelNodeThrowStatement | BabelNodeTryStatement | BabelNodeVariableDeclaration | BabelNodeWhileStatement | BabelNodeWithStatement | BabelNodeClassDeclaration | BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration | BabelNodeForOfStatement | BabelNodeImportDeclaration | BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeInterfaceDeclaration | BabelNodeTypeAlias | BabelNodeForAwaitStatement;
  declare type BabelNodeTerminatorless = BabelNodeBreakStatement | BabelNodeContinueStatement | BabelNodeReturnStatement | BabelNodeThrowStatement | BabelNodeYieldExpression | BabelNodeAwaitExpression;
  declare type BabelNodeCompletionStatement = BabelNodeBreakStatement | BabelNodeContinueStatement | BabelNodeReturnStatement | BabelNodeThrowStatement;
  declare type BabelNodeConditional = BabelNodeConditionalExpression | BabelNodeIfStatement;
  declare type BabelNodeLoop = BabelNodeDoWhileStatement | BabelNodeForInStatement | BabelNodeForStatement | BabelNodeWhileStatement | BabelNodeForOfStatement | BabelNodeForAwaitStatement;
  declare type BabelNodeWhile = BabelNodeDoWhileStatement | BabelNodeWhileStatement;
  declare type BabelNodeExpressionWrapper = BabelNodeExpressionStatement | BabelNodeTypeCastExpression | BabelNodeParenthesizedExpression;
  declare type BabelNodeFor = BabelNodeForInStatement | BabelNodeForStatement | BabelNodeForOfStatement | BabelNodeForAwaitStatement;
  declare type BabelNodeForXStatement = BabelNodeForInStatement | BabelNodeForOfStatement | BabelNodeForAwaitStatement;
  declare type BabelNodeFunction = BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeObjectMethod | BabelNodeArrowFunctionExpression | BabelNodeClassMethod;
  declare type BabelNodeFunctionParent = BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeProgram | BabelNodeObjectMethod | BabelNodeArrowFunctionExpression | BabelNodeClassMethod;
  declare type BabelNodePureish = BabelNodeFunctionDeclaration | BabelNodeFunctionExpression | BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeArrowFunctionExpression | BabelNodeClassDeclaration | BabelNodeClassExpression;
  declare type BabelNodeDeclaration = BabelNodeFunctionDeclaration | BabelNodeVariableDeclaration | BabelNodeClassDeclaration | BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration | BabelNodeImportDeclaration | BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeInterfaceDeclaration | BabelNodeTypeAlias;
  declare type BabelNodeLVal = BabelNodeIdentifier | BabelNodeMemberExpression | BabelNodeRestElement | BabelNodeAssignmentPattern | BabelNodeArrayPattern | BabelNodeObjectPattern;
  declare type BabelNodeLiteral = BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeRegExpLiteral | BabelNodeTemplateLiteral;
  declare type BabelNodeImmutable = BabelNodeStringLiteral | BabelNodeNumericLiteral | BabelNodeNullLiteral | BabelNodeBooleanLiteral | BabelNodeJSXAttribute | BabelNodeJSXClosingElement | BabelNodeJSXElement | BabelNodeJSXExpressionContainer | BabelNodeJSXOpeningElement | BabelNodeJSXText;
  declare type BabelNodeUserWhitespacable = BabelNodeObjectMethod | BabelNodeObjectProperty | BabelNodeObjectTypeCallProperty | BabelNodeObjectTypeIndexer | BabelNodeObjectTypeProperty;
  declare type BabelNodeMethod = BabelNodeObjectMethod | BabelNodeClassMethod;
  declare type BabelNodeObjectMember = BabelNodeObjectMethod | BabelNodeObjectProperty;
  declare type BabelNodeProperty = BabelNodeObjectProperty | BabelNodeClassProperty;
  declare type BabelNodeUnaryLike = BabelNodeUnaryExpression | BabelNodeSpreadElement | BabelNodeRestProperty;
  declare type BabelNodePattern = BabelNodeAssignmentPattern | BabelNodeArrayPattern | BabelNodeObjectPattern | BabelNodeRestElement;
  declare type BabelNodeClass = BabelNodeClassDeclaration | BabelNodeClassExpression;
  declare type BabelNodeModuleDeclaration = BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration | BabelNodeImportDeclaration;
  declare type BabelNodeExportDeclaration = BabelNodeExportAllDeclaration | BabelNodeExportDefaultDeclaration | BabelNodeExportNamedDeclaration;
  declare type BabelNodeModuleSpecifier = BabelNodeExportSpecifier | BabelNodeImportDefaultSpecifier | BabelNodeImportNamespaceSpecifier | BabelNodeImportSpecifier | BabelNodeExportDefaultSpecifier | BabelNodeExportNamespaceSpecifier;
  declare type BabelNodeFlow = BabelNodeAnyTypeAnnotation | BabelNodeArrayTypeAnnotation | BabelNodeBooleanTypeAnnotation | BabelNodeBooleanLiteralTypeAnnotation | BabelNodeNullLiteralTypeAnnotation | BabelNodeClassImplements | BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeExistentialTypeParam | BabelNodeFunctionTypeAnnotation | BabelNodeFunctionTypeParam | BabelNodeGenericTypeAnnotation | BabelNodeInterfaceExtends | BabelNodeInterfaceDeclaration | BabelNodeIntersectionTypeAnnotation | BabelNodeMixedTypeAnnotation | BabelNodeEmptyTypeAnnotation | BabelNodeNullableTypeAnnotation | BabelNodeNumericLiteralTypeAnnotation | BabelNodeNumberTypeAnnotation | BabelNodeStringLiteralTypeAnnotation | BabelNodeStringTypeAnnotation | BabelNodeThisTypeAnnotation | BabelNodeTupleTypeAnnotation | BabelNodeTypeofTypeAnnotation | BabelNodeTypeAlias | BabelNodeTypeAnnotation | BabelNodeTypeCastExpression | BabelNodeTypeParameter | BabelNodeTypeParameterDeclaration | BabelNodeTypeParameterInstantiation | BabelNodeObjectTypeAnnotation | BabelNodeObjectTypeCallProperty | BabelNodeObjectTypeIndexer | BabelNodeObjectTypeProperty | BabelNodeQualifiedTypeIdentifier | BabelNodeUnionTypeAnnotation | BabelNodeVoidTypeAnnotation;
  declare type BabelNodeFlowBaseAnnotation = BabelNodeAnyTypeAnnotation | BabelNodeBooleanTypeAnnotation | BabelNodeNullLiteralTypeAnnotation | BabelNodeMixedTypeAnnotation | BabelNodeEmptyTypeAnnotation | BabelNodeNumberTypeAnnotation | BabelNodeStringTypeAnnotation | BabelNodeThisTypeAnnotation | BabelNodeVoidTypeAnnotation;
  declare type BabelNodeFlowDeclaration = BabelNodeDeclareClass | BabelNodeDeclareFunction | BabelNodeDeclareInterface | BabelNodeDeclareModule | BabelNodeDeclareModuleExports | BabelNodeDeclareTypeAlias | BabelNodeDeclareVariable | BabelNodeInterfaceDeclaration | BabelNodeTypeAlias;
  declare type BabelNodeJSX = BabelNodeJSXAttribute | BabelNodeJSXClosingElement | BabelNodeJSXElement | BabelNodeJSXEmptyExpression | BabelNodeJSXExpressionContainer | BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression | BabelNodeJSXNamespacedName | BabelNodeJSXOpeningElement | BabelNodeJSXSpreadAttribute | BabelNodeJSXText;

  declare function anyTypeAnnotation(): BabelNodeAnyTypeAnnotation;
  declare function arrayExpression(elements: Array<null | BabelNodeExpression | BabelNodeSpreadElement>): BabelNodeArrayExpression;
  declare function arrayPattern(elements: Array<BabelNodeExpression>, typeAnnotation: any, decorators?: Array<BabelNodeDecorator>): BabelNodeArrayPattern;
  declare function arrayTypeAnnotation(elementType: any): BabelNodeArrayTypeAnnotation;
  declare function arrowFunctionExpression(params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement | BabelNodeExpression, async?: boolean, returnType?: any, typeParameters?: any): BabelNodeArrowFunctionExpression;
  declare function assignmentExpression(operator: BabelAssignmentOperator, left: BabelNodeLVal, right: BabelNodeExpression): BabelNodeAssignmentExpression;
  declare function assignmentPattern(left: BabelNodeIdentifier, right: BabelNodeExpression, decorators?: any): BabelNodeAssignmentPattern;
  declare function awaitExpression(argument: BabelNodeExpression): BabelNodeAwaitExpression;
  declare function binaryExpression(operator: BabelBinaryOperator, left: BabelNodeExpression, right: BabelNodeExpression): BabelNodeBinaryExpression;
  declare function bindExpression(object: any, callee: any): BabelNodeBindExpression;
  declare function blockStatement(body: Array<BabelNodeStatement>, directives?: Array<BabelNodeDirective>): BabelNodeBlockStatement;
  declare function booleanLiteral(value: boolean): BabelNodeBooleanLiteral;
  declare function booleanLiteralTypeAnnotation(): BabelNodeBooleanLiteralTypeAnnotation;
  declare function booleanTypeAnnotation(): BabelNodeBooleanTypeAnnotation;
  declare function breakStatement(label?: ?BabelNodeIdentifier): BabelNodeBreakStatement;
  declare function callExpression(callee: BabelNodeExpression, _arguments: Array<BabelNodeExpression | BabelNodeSpreadElement>): BabelNodeCallExpression;
  declare function catchClause(param: BabelNodeIdentifier, body: BabelNodeBlockStatement): BabelNodeCatchClause;
  declare function classBody(body: Array<BabelNodeClassMethod | BabelNodeClassProperty>): BabelNodeClassBody;
  declare function classDeclaration(id: BabelNodeIdentifier, superClass?: ?BabelNodeExpression, body: BabelNodeClassBody, decorators: Array<BabelNodeDecorator>, mixins?: any, typeParameters?: any, superTypeParameters?: any, _implements?: any): BabelNodeClassDeclaration;
  declare function classExpression(id?: ?BabelNodeIdentifier,  superClass?: ?BabelNodeExpression, body: BabelNodeClassBody, decorators: Array<BabelNodeDecorator>, _implements?: any, mixins?: any, superTypeParameters?: any, typeParameters?: any): BabelNodeClassExpression;
  declare function classImplements(id: any, typeParameters: any): BabelNodeClassImplements;
  declare function classMethod(kind: ?("get" | "set" | "method" | "constructor"), key: BabelNodeExpression | BabelNodeIdentifier | BabelNodeLiteral, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, computed?: boolean, _static?: boolean, async?: boolean, decorators?: any, generator?: boolean, returnType?: any, typeParameters?: any): BabelNodeClassMethod;
  declare function classProperty(key: any, value: any, typeAnnotation: any, decorators: any, computed?: boolean): BabelNodeClassProperty;
  declare function conditionalExpression(test: BabelNodeExpression, consequent: BabelNodeExpression, alternate: BabelNodeExpression): BabelNodeConditionalExpression;
  declare function continueStatement(label?: ?BabelNodeIdentifier): BabelNodeContinueStatement;
  declare function debuggerStatement(): BabelNodeDebuggerStatement;
  declare function declareClass(id: any, typeParameters: any, _extends: any, body: any): BabelNodeDeclareClass;
  declare function declareFunction(id: any): BabelNodeDeclareFunction;
  declare function declareInterface(id: any, typeParameters: any, _extends: any, body: any): BabelNodeDeclareInterface;
  declare function declareModule(id: any, body: any): BabelNodeDeclareModule;
  declare function declareModuleExports(typeAnnotation: any): BabelNodeDeclareModuleExports;
  declare function declareTypeAlias(id: any, typeParameters: any, right: any): BabelNodeDeclareTypeAlias;
  declare function declareVariable(id: any): BabelNodeDeclareVariable;
  declare function decorator(expression: BabelNodeExpression): BabelNodeDecorator;
  declare function directive(value: BabelNodeDirectiveLiteral): BabelNodeDirective;
  declare function directiveLiteral(value: string): BabelNodeDirectiveLiteral;
  declare function doExpression(body: BabelNodeBlockStatement): BabelNodeDoExpression;
  declare function doWhileStatement(test: BabelNodeExpression, body: BabelNodeStatement): BabelNodeDoWhileStatement;
  declare function emptyStatement(): BabelNodeEmptyStatement;
  declare function emptyTypeAnnotation(): BabelNodeEmptyTypeAnnotation;
  declare function existentialTypeParam(): BabelNodeExistentialTypeParam;
  declare function exportAllDeclaration(source: BabelNodeStringLiteral): BabelNodeExportAllDeclaration;
  declare function exportDefaultDeclaration(declaration: BabelNodeFunctionDeclaration | BabelNodeClassDeclaration | BabelNodeExpression): BabelNodeExportDefaultDeclaration;
  declare function exportDefaultSpecifier(exported: BabelNodeIdentifier): BabelNodeExportDefaultSpecifier;
  declare function exportNamedDeclaration(declaration?: ?BabelNodeDeclaration, specifiers: Array<BabelNodeExportSpecifier>, source?: ?BabelNodeStringLiteral): BabelNodeExportNamedDeclaration;
  declare function exportNamespaceSpecifier(exported: BabelNodeIdentifier): BabelNodeExportNamespaceSpecifier;
  declare function exportSpecifier(local: BabelNodeIdentifier, exported: BabelNodeIdentifier): BabelNodeExportSpecifier;
  declare function expressionStatement(expression: BabelNodeExpression): BabelNodeExpressionStatement;
  declare function file(program: BabelNodeProgram, comments: any, tokens: any): BabelNodeFile;
  declare function forAwaitStatement(left: BabelNodeVariableDeclaration | BabelNodeLVal, right: BabelNodeExpression, body: BabelNodeStatement): BabelNodeForAwaitStatement;
  declare function forInStatement(left: BabelNodeVariableDeclaration | BabelNodeLVal, right: BabelNodeExpression, body: BabelNodeStatement): BabelNodeForInStatement;
  declare function forOfStatement(left: BabelNodeVariableDeclaration | BabelNodeLVal, right: BabelNodeExpression, body: BabelNodeStatement): BabelNodeForOfStatement;
  declare function forStatement(init?: ?BabelNodeVariableDeclaration | BabelNodeExpression, test?: ?BabelNodeExpression, update?: ?BabelNodeExpression, body: BabelNodeStatement): BabelNodeForStatement;
  declare function functionDeclaration(id: BabelNodeIdentifier, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, generator?: boolean, async?: boolean, returnType?: any, typeParameters?: any): BabelNodeFunctionDeclaration;
  declare function functionExpression(id?: ?BabelNodeIdentifier, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, generator?: boolean, async?: boolean, returnType?: any, typeParameters?: any): BabelNodeFunctionExpression;
  declare function functionTypeAnnotation(typeParameters: any, params: any, rest: any, returnType: any): BabelNodeFunctionTypeAnnotation;
  declare function functionTypeParam(name: any, typeAnnotation: any): BabelNodeFunctionTypeParam;
  declare function genericTypeAnnotation(id: any, typeParameters: any): BabelNodeGenericTypeAnnotation;
  declare function identifier(name: string, decorators?: Array<BabelNodeDecorator>, typeAnnotation?: any): BabelNodeIdentifier;
  declare function ifStatement(test: BabelNodeExpression, consequent: BabelNodeStatement, alternate?: ?BabelNodeStatement): BabelNodeIfStatement;
  declare function importDeclaration(specifiers: any, source: BabelNodeStringLiteral): BabelNodeImportDeclaration;
  declare function importDefaultSpecifier(local: BabelNodeIdentifier): BabelNodeImportDefaultSpecifier;
  declare function importNamespaceSpecifier(local: BabelNodeIdentifier): BabelNodeImportNamespaceSpecifier;
  declare function importSpecifier(local: BabelNodeIdentifier, imported: BabelNodeIdentifier): BabelNodeImportSpecifier;
  declare function interfaceDeclaration(id: any, typeParameters: any, _extends: any, body: any): BabelNodeInterfaceDeclaration;
  declare function interfaceExtends(id: any, typeParameters: any): BabelNodeInterfaceExtends;
  declare function intersectionTypeAnnotation(types: any): BabelNodeIntersectionTypeAnnotation;
  declare function jSXAttribute(name: BabelNodeJSXIdentifier | BabelNodeJSXNamespacedName, value?: ?BabelNodeJSXElement | BabelNodeStringLiteral | BabelNodeJSXExpressionContainer): BabelNodeJSXAttribute;
  declare function jSXClosingElement(name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression): BabelNodeJSXClosingElement;
  declare function jSXElement(openingElement: BabelNodeJSXOpeningElement, closingElement?: ?BabelNodeJSXClosingElement, children: any, selfClosing: any): BabelNodeJSXElement;
  declare function jSXEmptyExpression(): BabelNodeJSXEmptyExpression;
  declare function jSXExpressionContainer(expression: BabelNodeExpression): BabelNodeJSXExpressionContainer;
  declare function jSXIdentifier(name: string): BabelNodeJSXIdentifier;
  declare function jSXMemberExpression(object: BabelNodeJSXMemberExpression | BabelNodeJSXIdentifier, property: BabelNodeJSXIdentifier): BabelNodeJSXMemberExpression;
  declare function jSXNamespacedName(namespace: BabelNodeJSXIdentifier, name: BabelNodeJSXIdentifier): BabelNodeJSXNamespacedName;
  declare function jSXOpeningElement(name: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression, selfClosing?: boolean, attributes: any): BabelNodeJSXOpeningElement;
  declare function jSXSpreadAttribute(argument: BabelNodeExpression): BabelNodeJSXSpreadAttribute;
  declare function jSXText(value: string): BabelNodeJSXText;
  declare function labeledStatement(label: BabelNodeIdentifier, body: BabelNodeStatement): BabelNodeLabeledStatement;
  declare function logicalExpression(operator: BabelLogicalOperator, left: BabelNodeExpression, right: BabelNodeExpression): BabelNodeLogicalExpression;
  declare function memberExpression(object: BabelNodeExpression, property: BabelNodeExpression | BabelNodeIdentifier, computed?: boolean): BabelNodeMemberExpression;
  declare function metaProperty(meta: string, property: string): BabelNodeMetaProperty;
  declare function mixedTypeAnnotation(): BabelNodeMixedTypeAnnotation;
  declare function newExpression(callee: BabelNodeExpression, _arguments: Array<BabelNodeExpression>): BabelNodeNewExpression;
  declare function noop(): BabelNodeNoop;
  declare function nullLiteral(): BabelNodeNullLiteral;
  declare function nullLiteralTypeAnnotation(): BabelNodeNullLiteralTypeAnnotation;
  declare function nullableTypeAnnotation(typeAnnotation: any): BabelNodeNullableTypeAnnotation;
  declare function numberTypeAnnotation(): BabelNodeNumberTypeAnnotation;
  declare function numericLiteral(value: number): BabelNodeNumericLiteral;
  declare function numericLiteralTypeAnnotation(): BabelNodeNumericLiteralTypeAnnotation;
  declare function objectExpression(properties: Array<BabelNodeObjectMethod | BabelNodeObjectProperty | BabelNodeSpreadElement>): BabelNodeObjectExpression;
  declare function objectMethod(kind: BabelObjectMethodKind, key: BabelNodeExpression | BabelNodeIdentifier | BabelNodeLiteral, params: Array<BabelNodeLVal>, body: BabelNodeBlockStatement, computed?: boolean, async?: boolean, decorators?: any, generator?: boolean, returnType?: any, typeParameters?: any): BabelNodeObjectMethod;
  declare function objectPattern(properties: Array<BabelNodeRestProperty | BabelNodeProperty>, typeAnnotation: any, decorators?: Array<BabelNodeDecorator>): BabelNodeObjectPattern;
  declare function objectProperty(key: BabelNodeExpression | BabelNodeIdentifier | BabelNodeLiteral, value: BabelNodeExpression, computed?: boolean, shorthand?: boolean, decorators: ?Array<BabelNodeDecorator>): BabelNodeObjectProperty;
  declare function objectTypeAnnotation(properties: any, indexers: any, callProperties: any): BabelNodeObjectTypeAnnotation;
  declare function objectTypeCallProperty(value: any): BabelNodeObjectTypeCallProperty;
  declare function objectTypeIndexer(id: any, key: any, value: any): BabelNodeObjectTypeIndexer;
  declare function objectTypeProperty(key: any, value: any): BabelNodeObjectTypeProperty;
  declare function parenthesizedExpression(expression: BabelNodeExpression): BabelNodeParenthesizedExpression;
  declare function program(body: Array<BabelNodeStatement>, directives?: Array<BabelNodeDirective>): BabelNodeProgram;
  declare function qualifiedTypeIdentifier(id: any, qualification: any): BabelNodeQualifiedTypeIdentifier;
  declare function regExpLiteral(pattern: string, flags?: string): BabelNodeRegExpLiteral;
  declare function restElement(argument: BabelNodeLVal, typeAnnotation: any, decorators?: any): BabelNodeRestElement;
  declare function restProperty(argument: BabelNodeLVal): BabelNodeRestProperty;
  declare function returnStatement(argument?: ?BabelNodeExpression): BabelNodeReturnStatement;
  declare function sequenceExpression(expressions: Array<BabelNodeExpression>): BabelNodeSequenceExpression;
  declare function spreadElement(argument: BabelNodeExpression): BabelNodeSpreadElement;
  declare function stringLiteral(value: string): BabelNodeStringLiteral;
  declare function stringLiteralTypeAnnotation(): BabelNodeStringLiteralTypeAnnotation;
  declare function stringTypeAnnotation(): BabelNodeStringTypeAnnotation;
  declare function switchCase(test?: ?BabelNodeExpression, consequent: Array<BabelNodeStatement>): BabelNodeSwitchCase;
  declare function switchStatement(discriminant: BabelNodeExpression, cases: Array<BabelNodeSwitchCase>): BabelNodeSwitchStatement;
  declare function taggedTemplateExpression(tag: BabelNodeExpression, quasi: BabelNodeTemplateLiteral): BabelNodeTaggedTemplateExpression;
  declare function templateElement(value: any, tail?: boolean): BabelNodeTemplateElement;
  declare function templateLiteral(quasis: Array<BabelNodeTemplateLiteral>, expressions: Array<BabelNodeExpression>): BabelNodeTemplateLiteral;
  declare function thisExpression(): BabelNodeThisExpression;
  declare function thisTypeAnnotation(): BabelNodeThisTypeAnnotation;
  declare function throwStatement(argument: BabelNodeExpression): BabelNodeThrowStatement;
  declare function tryStatement(block: any, handler?: any, finalizer?: ?BabelNodeBlockStatement, body?: ?BabelNodeBlockStatement): BabelNodeTryStatement;
  declare function tupleTypeAnnotation(types: any): BabelNodeTupleTypeAnnotation;
  declare function typeAlias(id: any, typeParameters: any, right: any): BabelNodeTypeAlias;
  declare function typeAnnotation(typeAnnotation: any): BabelNodeTypeAnnotation;
  declare function typeCastExpression(expression: any, typeAnnotation: any): BabelNodeTypeCastExpression;
  declare function typeParameter(bound: any): BabelNodeTypeParameter;
  declare function typeParameterDeclaration(params: any): BabelNodeTypeParameterDeclaration;
  declare function typeParameterInstantiation(params: any): BabelNodeTypeParameterInstantiation;
  declare function typeofTypeAnnotation(argument: any): BabelNodeTypeofTypeAnnotation;
  declare function unaryExpression(operator: BabelUnaryOperator, argument: BabelNodeExpression, prefix?: boolean): BabelNodeUnaryExpression;
  declare function unionTypeAnnotation(types: any): BabelNodeUnionTypeAnnotation;
  declare function updateExpression(operator: BabelUpdateOperator, argument: BabelNodeExpression, prefix?: boolean): BabelNodeUpdateExpression;
  declare function variableDeclaration(kind: BabelVariableKind, declarations: Array<BabelNodeVariableDeclarator>): BabelNodeVariableDeclaration;
  declare function variableDeclarator(id: BabelNodeLVal, init?: ?BabelNodeExpression): BabelNodeVariableDeclarator;
  declare function voidTypeAnnotation(): BabelNodeVoidTypeAnnotation;
  declare function whileStatement(test: BabelNodeExpression, body: BabelNodeStatement): BabelNodeWhileStatement;
  declare function withStatement(object: BabelNodeExpression, body: BabelNodeStatement): BabelNodeWithStatement;
  declare function yieldExpression(argument?: ?BabelNodeExpression, delegate?: boolean): BabelNodeYieldExpression;

  declare function isArrayExpression(node: Object, opts?: Object): boolean;
  declare function isAssignmentExpression(node: Object, opts?: Object): boolean;
  declare function isBinaryExpression(node: Object, opts?: Object): boolean;
  declare function isDirective(node: Object, opts?: Object): boolean;
  declare function isDirectiveLiteral(node: Object, opts?: Object): boolean;
  declare function isBlockStatement(node: Object, opts?: Object): boolean;
  declare function isBreakStatement(node: Object, opts?: Object): boolean;
  declare function isCallExpression(node: Object, opts?: Object): boolean;
  declare function isCatchClause(node: Object, opts?: Object): boolean;
  declare function isConditionalExpression(node: Object, opts?: Object): boolean;
  declare function isContinueStatement(node: Object, opts?: Object): boolean;
  declare function isDebuggerStatement(node: Object, opts?: Object): boolean;
  declare function isDoWhileStatement(node: Object, opts?: Object): boolean;
  declare function isEmptyStatement(node: Object, opts?: Object): boolean;
  declare function isExpressionStatement(node: Object, opts?: Object): boolean;
  declare function isFile(node: Object, opts?: Object): boolean;
  declare function isForInStatement(node: Object, opts?: Object): boolean;
  declare function isForStatement(node: Object, opts?: Object): boolean;
  declare function isFunctionDeclaration(node: Object, opts?: Object): boolean;
  declare function isFunctionExpression(node: Object, opts?: Object): boolean;
  declare function isIdentifier(node: Object, opts?: Object): boolean;
  declare function isIfStatement(node: Object, opts?: Object): boolean;
  declare function isLabeledStatement(node: Object, opts?: Object): boolean;
  declare function isStringLiteral(node: Object, opts?: Object): boolean;
  declare function isNumericLiteral(node: Object, opts?: Object): boolean;
  declare function isNullLiteral(node: Object, opts?: Object): boolean;
  declare function isBooleanLiteral(node: Object, opts?: Object): boolean;
  declare function isRegExpLiteral(node: Object, opts?: Object): boolean;
  declare function isLogicalExpression(node: Object, opts?: Object): boolean;
  declare function isMemberExpression(node: Object, opts?: Object): boolean;
  declare function isNewExpression(node: Object, opts?: Object): boolean;
  declare function isProgram(node: Object, opts?: Object): boolean;
  declare function isObjectExpression(node: Object, opts?: Object): boolean;
  declare function isObjectMethod(node: Object, opts?: Object): boolean;
  declare function isObjectProperty(node: Object, opts?: Object): boolean;
  declare function isRestElement(node: Object, opts?: Object): boolean;
  declare function isReturnStatement(node: Object, opts?: Object): boolean;
  declare function isSequenceExpression(node: Object, opts?: Object): boolean;
  declare function isSwitchCase(node: Object, opts?: Object): boolean;
  declare function isSwitchStatement(node: Object, opts?: Object): boolean;
  declare function isThisExpression(node: Object, opts?: Object): boolean;
  declare function isThrowStatement(node: Object, opts?: Object): boolean;
  declare function isTryStatement(node: Object, opts?: Object): boolean;
  declare function isUnaryExpression(node: Object, opts?: Object): boolean;
  declare function isUpdateExpression(node: Object, opts?: Object): boolean;
  declare function isVariableDeclaration(node: Object, opts?: Object): boolean;
  declare function isVariableDeclarator(node: Object, opts?: Object): boolean;
  declare function isWhileStatement(node: Object, opts?: Object): boolean;
  declare function isWithStatement(node: Object, opts?: Object): boolean;
  declare function isAssignmentPattern(node: Object, opts?: Object): boolean;
  declare function isArrayPattern(node: Object, opts?: Object): boolean;
  declare function isArrowFunctionExpression(node: Object, opts?: Object): boolean;
  declare function isClassBody(node: Object, opts?: Object): boolean;
  declare function isClassDeclaration(node: Object, opts?: Object): boolean;
  declare function isClassExpression(node: Object, opts?: Object): boolean;
  declare function isExportAllDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportDefaultDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportNamedDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportSpecifier(node: Object, opts?: Object): boolean;
  declare function isForOfStatement(node: Object, opts?: Object): boolean;
  declare function isImportDeclaration(node: Object, opts?: Object): boolean;
  declare function isImportDefaultSpecifier(node: Object, opts?: Object): boolean;
  declare function isImportNamespaceSpecifier(node: Object, opts?: Object): boolean;
  declare function isImportSpecifier(node: Object, opts?: Object): boolean;
  declare function isMetaProperty(node: Object, opts?: Object): boolean;
  declare function isClassMethod(node: Object, opts?: Object): boolean;
  declare function isObjectPattern(node: Object, opts?: Object): boolean;
  declare function isSpreadElement(node: Object, opts?: Object): boolean;
  declare function isSuper(node: Object, opts?: Object): boolean;
  declare function isTaggedTemplateExpression(node: Object, opts?: Object): boolean;
  declare function isTemplateElement(node: Object, opts?: Object): boolean;
  declare function isTemplateLiteral(node: Object, opts?: Object): boolean;
  declare function isYieldExpression(node: Object, opts?: Object): boolean;
  declare function isAnyTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isArrayTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isBooleanTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isBooleanLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNullLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isClassImplements(node: Object, opts?: Object): boolean;
  declare function isClassProperty(node: Object, opts?: Object): boolean;
  declare function isDeclareClass(node: Object, opts?: Object): boolean;
  declare function isDeclareFunction(node: Object, opts?: Object): boolean;
  declare function isDeclareInterface(node: Object, opts?: Object): boolean;
  declare function isDeclareModule(node: Object, opts?: Object): boolean;
  declare function isDeclareModuleExports(node: Object, opts?: Object): boolean;
  declare function isDeclareTypeAlias(node: Object, opts?: Object): boolean;
  declare function isDeclareVariable(node: Object, opts?: Object): boolean;
  declare function isExistentialTypeParam(node: Object, opts?: Object): boolean;
  declare function isFunctionTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isFunctionTypeParam(node: Object, opts?: Object): boolean;
  declare function isGenericTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isInterfaceExtends(node: Object, opts?: Object): boolean;
  declare function isInterfaceDeclaration(node: Object, opts?: Object): boolean;
  declare function isIntersectionTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isMixedTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isEmptyTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNullableTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNumericLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isNumberTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isStringLiteralTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isStringTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isThisTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTupleTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTypeofTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTypeAlias(node: Object, opts?: Object): boolean;
  declare function isTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isTypeCastExpression(node: Object, opts?: Object): boolean;
  declare function isTypeParameter(node: Object, opts?: Object): boolean;
  declare function isTypeParameterDeclaration(node: Object, opts?: Object): boolean;
  declare function isTypeParameterInstantiation(node: Object, opts?: Object): boolean;
  declare function isObjectTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isObjectTypeCallProperty(node: Object, opts?: Object): boolean;
  declare function isObjectTypeIndexer(node: Object, opts?: Object): boolean;
  declare function isObjectTypeProperty(node: Object, opts?: Object): boolean;
  declare function isQualifiedTypeIdentifier(node: Object, opts?: Object): boolean;
  declare function isUnionTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isVoidTypeAnnotation(node: Object, opts?: Object): boolean;
  declare function isJSXAttribute(node: Object, opts?: Object): boolean;
  declare function isJSXClosingElement(node: Object, opts?: Object): boolean;
  declare function isJSXElement(node: Object, opts?: Object): boolean;
  declare function isJSXEmptyExpression(node: Object, opts?: Object): boolean;
  declare function isJSXExpressionContainer(node: Object, opts?: Object): boolean;
  declare function isJSXIdentifier(node: Object, opts?: Object): boolean;
  declare function isJSXMemberExpression(node: Object, opts?: Object): boolean;
  declare function isJSXNamespacedName(node: Object, opts?: Object): boolean;
  declare function isJSXOpeningElement(node: Object, opts?: Object): boolean;
  declare function isJSXSpreadAttribute(node: Object, opts?: Object): boolean;
  declare function isJSXText(node: Object, opts?: Object): boolean;
  declare function isNoop(node: Object, opts?: Object): boolean;
  declare function isParenthesizedExpression(node: Object, opts?: Object): boolean;
  declare function isAwaitExpression(node: Object, opts?: Object): boolean;
  declare function isForAwaitStatement(node: Object, opts?: Object): boolean;
  declare function isBindExpression(node: Object, opts?: Object): boolean;
  declare function isDecorator(node: Object, opts?: Object): boolean;
  declare function isDoExpression(node: Object, opts?: Object): boolean;
  declare function isExportDefaultSpecifier(node: Object, opts?: Object): boolean;
  declare function isExportNamespaceSpecifier(node: Object, opts?: Object): boolean;
  declare function isRestProperty(node: Object, opts?: Object): boolean;
  declare function isExpression(node: Object, opts?: Object): boolean;
  declare function isBinary(node: Object, opts?: Object): boolean;
  declare function isScopable(node: Object, opts?: Object): boolean;
  declare function isBlockParent(node: Object, opts?: Object): boolean;
  declare function isBlock(node: Object, opts?: Object): boolean;
  declare function isStatement(node: Object, opts?: Object): boolean;
  declare function isTerminatorless(node: Object, opts?: Object): boolean;
  declare function isCompletionStatement(node: Object, opts?: Object): boolean;
  declare function isConditional(node: Object, opts?: Object): boolean;
  declare function isLoop(node: Object, opts?: Object): boolean;
  declare function isWhile(node: Object, opts?: Object): boolean;
  declare function isExpressionWrapper(node: Object, opts?: Object): boolean;
  declare function isFor(node: Object, opts?: Object): boolean;
  declare function isForXStatement(node: Object, opts?: Object): boolean;
  declare function isFunction(node: Object, opts?: Object): boolean;
  declare function isFunctionParent(node: Object, opts?: Object): boolean;
  declare function isPureish(node: Object, opts?: Object): boolean;
  declare function isDeclaration(node: Object, opts?: Object): boolean;
  declare function isLVal(node: Object, opts?: Object): boolean;
  declare function isLiteral(node: Object, opts?: Object): boolean;
  declare function isImmutable(node: Object, opts?: Object): boolean;
  declare function isUserWhitespacable(node: Object, opts?: Object): boolean;
  declare function isMethod(node: Object, opts?: Object): boolean;
  declare function isObjectMember(node: Object, opts?: Object): boolean;
  declare function isProperty(node: Object, opts?: Object): boolean;
  declare function isUnaryLike(node: Object, opts?: Object): boolean;
  declare function isPattern(node: Object, opts?: Object): boolean;
  declare function isClass(node: Object, opts?: Object): boolean;
  declare function isModuleDeclaration(node: Object, opts?: Object): boolean;
  declare function isExportDeclaration(node: Object, opts?: Object): boolean;
  declare function isModuleSpecifier(node: Object, opts?: Object): boolean;
  declare function isFlow(node: Object, opts?: Object): boolean;
  declare function isFlowBaseAnnotation(node: Object, opts?: Object): boolean;
  declare function isFlowDeclaration(node: Object, opts?: Object): boolean;
  declare function isJSX(node: Object, opts?: Object): boolean;
  declare function isNumberLiteral(node: Object, opts?: Object): boolean;
  declare function isRegexLiteral(node: Object, opts?: Object): boolean;

  declare function isValidIdentifier(name: string): boolean;
  declare function getBindingIdentifiers(
    node: Object | Array<Object>,
    duplicates?: boolean,
    outerOnly?: boolean
  ): Object;
  declare function getOuterBindingIdentifiers(
    node: Object | Array<Object>,
    duplicates?: boolean,
  ): Object;
  declare var VISITOR_KEYS: {[id:string]: Function};
  declare function valueToNode(value: any): BabelNodeExpression;
  declare function cloneDeep(node: BabelNode): BabelNode;
}


/**
 * We include stubs for each file inside this npm package in case you need to
 * require those files directly. Feel free to delete any files that aren't
 * needed.
 */
declare module 'babel-types/lib/constants' {
  declare module.exports: any;
}

declare module 'babel-types/lib/converters' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/core' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/es2015' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/experimental' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/flow' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/index' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/init' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/jsx' {
  declare module.exports: any;
}

declare module 'babel-types/lib/definitions/misc' {
  declare module.exports: any;
}

declare module 'babel-types/lib/flow' {
  declare module.exports: any;
}

declare module 'babel-types/lib/index' {
  declare module.exports: any;
}

declare module 'babel-types/lib/react' {
  declare module.exports: any;
}

declare module 'babel-types/lib/retrievers' {
  declare module.exports: any;
}

declare module 'babel-types/lib/validators' {
  declare module.exports: any;
}

// Filename aliases
declare module 'babel-types/lib/constants.js' {
  declare module.exports: $Exports<'babel-types/lib/constants'>;
}
declare module 'babel-types/lib/converters.js' {
  declare module.exports: $Exports<'babel-types/lib/converters'>;
}
declare module 'babel-types/lib/definitions/core.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/core'>;
}
declare module 'babel-types/lib/definitions/es2015.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/es2015'>;
}
declare module 'babel-types/lib/definitions/experimental.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/experimental'>;
}
declare module 'babel-types/lib/definitions/flow.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/flow'>;
}
declare module 'babel-types/lib/definitions/index.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/index'>;
}
declare module 'babel-types/lib/definitions/init.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/init'>;
}
declare module 'babel-types/lib/definitions/jsx.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/jsx'>;
}
declare module 'babel-types/lib/definitions/misc.js' {
  declare module.exports: $Exports<'babel-types/lib/definitions/misc'>;
}
declare module 'babel-types/lib/flow.js' {
  declare module.exports: $Exports<'babel-types/lib/flow'>;
}
declare module 'babel-types/lib/index.js' {
  declare module.exports: $Exports<'babel-types/lib/index'>;
}
declare module 'babel-types/lib/react.js' {
  declare module.exports: $Exports<'babel-types/lib/react'>;
}
declare module 'babel-types/lib/retrievers.js' {
  declare module.exports: $Exports<'babel-types/lib/retrievers'>;
}
declare module 'babel-types/lib/validators.js' {
  declare module.exports: $Exports<'babel-types/lib/validators'>;
}
